{"remainingRequest":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/node_modules/vue-loader/lib/index.js??vue-loader-options!/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/src/components/ThreeboxExample.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/src/components/ThreeboxExample.vue","mtime":1638930530000},{"path":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/node_modules/cache-loader/dist/cjs.js","mtime":1637704935000},{"path":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/node_modules/babel-loader/lib/index.js","mtime":1637705426000},{"path":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/node_modules/cache-loader/dist/cjs.js","mtime":1637704935000},{"path":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/node_modules/vue-loader/lib/index.js","mtime":1637705662000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBtYXBib3hnbCBmcm9tICJtYXBib3gtZ2wiOwppbXBvcnQgKiBhcyBNYXBib3hEcmF3IGZyb20gJ21hcGJveC1nbC1kcmF3JzsKaW1wb3J0IHRocmVlYm94IGZyb20gInRocmVlYm94LXBsdWdpbi9kaXN0L3RocmVlYm94IjsKaW1wb3J0IHsgVGhyZWVib3ggfSBmcm9tICd0aHJlZWJveC1wbHVnaW4nOwppbXBvcnQgUHVsc2UgZnJvbSAiLi9QdWxzZXMvUHVsc2UiOwppbXBvcnQgKiBhcyB0dXJmIGZyb20gJ0B0dXJmL3R1cmYnOwppbXBvcnQgUmFuZ2VTbGlkZXIgZnJvbSAiLi9SYW5nZVNsaWRlciIKCgpsZXQgcHVsc2UgPSBuZXcgUHVsc2UoNDAwLCA0MDAwLCB0cnVlKTsKdGhyZWVib3gKCgovLyBSZXR1cm5zIHRydWUgaWYgZmluZHMgYSBkZWZpbmVkIGtleSBpbiB0aGUgaW5wdXQgYXJyYXkgb2YgZGljdGlvbmFyaWVzCmZ1bmN0aW9uIGtleUluRGljdGlvbmFyeSAoZGljdGlvbmFyaWVzLCBrZXlUb0ZpbmQpIHsKICAgIGZvciAodmFyIGkgaW4gZGljdGlvbmFyaWVzKSB7CiAgICAgICAgaWYgKGRpY3Rpb25hcmllc1tpXVsnaWQnXSA9PSBrZXlUb0ZpbmQpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWUKICAgICAgICB9CiAgICB9Cn0KCgovLyBSZXR1cm5zIGEgbGlzdCBvZiBjZW50cm9pZHMgb2YgbXVsdGlwbGUgTGluZVN0cmluZ3MKZnVuY3Rpb24gbGluZUNlbnRyb2lkcyhsaW5lcykgewogIGNvbnN0IGNlbnRyb2lkcyA9IFtdOwogIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHsKICAgIGNvbnN0IGxpbmUgPSB0dXJmLmxpbmVTdHJpbmcobGluZXMuZmVhdHVyZXNbaV0pCiAgICBjb25zdCBjdHIgPSB0dXJmLmNlbnRyb2lkKGxpbmVbJ2dlb21ldHJ5J11bJ2Nvb3JkaW5hdGVzJ10pCiAgICBjZW50cm9pZHMucHVzaChjdHIpCiAgfQogIHJldHVybiBjZW50cm9pZHMKfQoKCi8vIFJldHVybnMgcG9pbnRzIGFsb25nIGEgTGluZVN0cmluZyBkaXZpZGVkIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBsZW5ndGggaW4gbWV0ZXJzCmZ1bmN0aW9uIGRpdmlkZUxpbmVTdHJpbmcobGluZSwgbGVuZ3RoPTEwMCkgewogIGNvbnN0IGNodW5rcyA9IHR1cmYubGluZUNodW5rKGxpbmUsIGxlbmd0aCwge3VuaXRzOiAnbWV0ZXJzJ30pCiAgcmV0dXJuIGxpbmVDZW50cm9pZHMoY2h1bmtzKQp9CgoKLy8gRXh0cmFjdCBkcmF3biBzaGFwZSBhbmQgY29udmVydCBpdCB0byBhIHBvbHlnb24KZnVuY3Rpb24gZ2V0UG9seWdvbkRyYXduKGRyYXcpewogIGNvbnN0IGRhdGEgPSBkcmF3LmdldEFsbCgpCiAgcmV0dXJuIHR1cmYucG9seWdvbihkYXRhLmZlYXR1cmVzWzBdWydnZW9tZXRyeSddWydjb29yZGluYXRlcyddKQp9CgoKLy8gRXh0cmFjdCBpbnRlcm5hbCBza2VsZXRvbiBvZiBhIHNoYXBlCmZ1bmN0aW9uIHZvcm9ub2lTa2VsZXRvbihkcmF3KXsKICBjb25zdCBwb2wgPSBnZXRQb2x5Z29uRHJhd24oZHJhdykKICBjb25zdCBsaW5lID0gdHVyZi5wb2x5Z29uVG9MaW5lKHBvbCkKICBjb25zdCBjaHVua3MgPSB0dXJmLmxpbmVDaHVuayhsaW5lLCAwLjAxKQogIGNvbnN0IGNlbnRyb2lkcyA9IGxpbmVDZW50cm9pZHMoY2h1bmtzKQogIGNvbnN0IGNlbnRyb2lkc19naiA9IHsKICAgICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIiwKICAgICJmZWF0dXJlcyI6IGNlbnRyb2lkcwogIH0KICBjb25zdCB2b3Jvbm9pID0gdHVyZi52b3Jvbm9pKGNlbnRyb2lkc19naikKICAvLyBJdGVyYXRlIG92ZXIgdm9yb25vaSBwb2x5Z29ucyB0byBleHRyYWN0IHNlZ21lbnRzIGluc2lkZSBkcmF3aW5nCiAgY29uc3Qgdm9yb25vaUxpbmVzID0gW107CiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2b3Jvbm9pLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7CiAgICBjb25zdCB2b3Jvbm9pUG9seWdvbiA9IHR1cmYucG9seWdvbih2b3Jvbm9pLmZlYXR1cmVzW2ldWydnZW9tZXRyeSddWydjb29yZGluYXRlcyddKTsKICAgIGNvbnN0IHZvcm9ub2lMaW5lID0gdHVyZi5wb2x5Z29uVG9MaW5lKHZvcm9ub2lQb2x5Z29uKQogICAgY29uc3Qgdm9yb25vaVNlZ21lbnRzID0gdHVyZi5saW5lU2VnbWVudCh2b3Jvbm9pTGluZSkKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm9yb25vaVNlZ21lbnRzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7CiAgICAgIGNvbnN0IHNlZ21lbnRDZW50cm9pZCA9IHR1cmYuY2VudHJvaWQodm9yb25vaVNlZ21lbnRzLmZlYXR1cmVzW2ldKQogICAgICBpZiAodHVyZi5ib29sZWFuQ29udGFpbnMocG9sLCBzZWdtZW50Q2VudHJvaWQpKSB7CiAgICAgICAgdm9yb25vaUxpbmVzLnB1c2godm9yb25vaVNlZ21lbnRzLmZlYXR1cmVzW2ldKQogICAgICB9CiAgICB9CiAgfQogIGNvbnN0IHZvcm9ub2lMaW5lc0dlb0pTT04gPSB7CiAgICAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiIsCiAgICAiZmVhdHVyZXMiOiB2b3Jvbm9pTGluZXMKICB9CiAgY29uc3Qgdm9yb25vaUxpbmVzQ29tYmluZWQgPSB0dXJmLmNvbWJpbmUodm9yb25vaUxpbmVzR2VvSlNPTikKICBjb25zdCB2b3Jvbm9pTGluZXNTaW1wbGlmaWVkID0gdHVyZi5zaW1wbGlmeSh2b3Jvbm9pTGluZXNDb21iaW5lZCwKICAgIHt0b2xlcmFuY2U6IDUsIG11dGF0ZTogdHJ1ZX0pCiAgcmV0dXJuIHZvcm9ub2lMaW5lc1NpbXBsaWZpZWQKfQoKCi8vIEdlbmVyYXRlIHNrZWxldG9uIGFuZCBidWZmZXIgYWNjb3JkaW5nIHRvIHNvbWUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMKZnVuY3Rpb24gYnVmZmVyRHJhd1NrZWxldG9uKHNrZWxldG9uKSB7CiAgY29uc3QgYnVmZmVyZWRTa2VsZXRvbnMgPSBbXQogIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7CiAgICBjb25zdCBza2VsZXRvbkJ1ZmZlciA9IHR1cmYuYnVmZmVyKHNrZWxldG9uLCAzMCAqIChpKzEpLCB7dW5pdHM6ICdtZXRlcnMnfSkKICAgIGNvbnN0IGRpc3NvbHZlZFNrZWxldG9uID0gdHVyZi5kaXNzb2x2ZShza2VsZXRvbkJ1ZmZlcikKICAgIGJ1ZmZlcmVkU2tlbGV0b25zLnB1c2godHVyZi5saW5lU3RyaW5nKGRpc3NvbHZlZFNrZWxldG9uLmZlYXR1cmVzWzBdWydnZW9tZXRyeSddWydjb29yZGluYXRlcyddWzBdKSkKICB9CiAgcmV0dXJuIGJ1ZmZlcmVkU2tlbGV0b25zCn0KCgovLyBTdWJkaXZpZGUgYSBkcmF3biBzaGFwZSB1c2luZyBWb3Jvbm9pIHBhdHRlcm5zCmZ1bmN0aW9uIHN1YmRpdmlkZVNoYXBlKGRyYXcpIHsKICBjb25zdCBza2VsZXRvbiA9IHZvcm9ub2lTa2VsZXRvbihkcmF3KQogIGNvbnN0IHNrZWxldG9uQnVmZmVyU21hbGwgPSB0dXJmLmJ1ZmZlcihza2VsZXRvbiwgMC4xLCB7dW5pdHM6ICdtZXRlcnMnfSkuZmVhdHVyZXNbMF0KICBjb25zdCBza2VsZXRvbkxpbmUgPSB0dXJmLnBvbHlnb25Ub0xpbmUoc2tlbGV0b25CdWZmZXJTbWFsbCkKICBjb25zdCBkaXZpZGVkU2tlbGV0b24gPSBkaXZpZGVMaW5lU3RyaW5nKHR1cmYuY29tYmluZShza2VsZXRvbkxpbmUpKQogIGNvbnN0IHZvcm9ub2lTa2VsZXRvbkJ1ZmZlcnMgPSBidWZmZXJEcmF3U2tlbGV0b24oc2tlbGV0b24pCiAgY29uc3QgcGVycGVuZGljdWxhckxpbmVzID0gW10KICBmb3IgKGxldCBpID0gMDsgaSA8IGRpdmlkZWRTa2VsZXRvbi5sZW5ndGg7IGkrKykgewogICAgdmFyIG9yaWdpbmFsUG9pbnQgPSBkaXZpZGVkU2tlbGV0b25baV0KICAgIGNvbnN0IG5lYXJlc3RQb2ludHMgPSBbb3JpZ2luYWxQb2ludFsnZ2VvbWV0cnknXVsnY29vcmRpbmF0ZXMnXV0KICAgIGZvciAobGV0IGogPSAwOyBqIDwgdm9yb25vaVNrZWxldG9uQnVmZmVycy5sZW5ndGg7IGorKykgewogICAgICBjb25zdCBidWZmZXIgPSB2b3Jvbm9pU2tlbGV0b25CdWZmZXJzW2pdCiAgICAgIGNvbnN0IG5leHRQb2ludCA9IHR1cmYubmVhcmVzdFBvaW50T25MaW5lKGJ1ZmZlciwgdHVyZi5wb2ludChvcmlnaW5hbFBvaW50WydnZW9tZXRyeSddWydjb29yZGluYXRlcyddKSkKICAgICAgbmVhcmVzdFBvaW50cy5wdXNoKG5leHRQb2ludFsnZ2VvbWV0cnknXVsnY29vcmRpbmF0ZXMnXSkKICAgICAgb3JpZ2luYWxQb2ludCA9IG5leHRQb2ludAogICAgfQogICAgcGVycGVuZGljdWxhckxpbmVzLnB1c2godHVyZi5saW5lU3RyaW5nKG5lYXJlc3RQb2ludHMpKQogIH0KICAvLyBCdWZmZXIgbGluZXMgYW5kIHN1YnRyYWN0CiAgY29uc3QgY2VudGVybGluZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKHBlcnBlbmRpY3VsYXJMaW5lcy5jb25jYXQoc2tlbGV0b24uZmVhdHVyZXMsIHZvcm9ub2lTa2VsZXRvbkJ1ZmZlcnMpKQogIHJldHVybiBjZW50ZXJsaW5lcwp9CgoKZnVuY3Rpb24gZ2VuZXJhdGVCbG9ja3MoZHJhdywgc3RyZWV0X3dpZHRoKSB7CiAgY29uc3QgYnVmZmVyZWRDZW50ZXJsaW5lcyA9IHR1cmYuZGlzc29sdmUodHVyZi5idWZmZXIoc3ViZGl2aWRlU2hhcGUoZHJhdyksIHN0cmVldF93aWR0aC8yLCB7dW5pdHM6ICdtZXRlcnMnfSkpCiAgcmV0dXJuIHR1cmYuZGlmZmVyZW5jZShnZXRQb2x5Z29uRHJhd24oZHJhdyksIGJ1ZmZlcmVkQ2VudGVybGluZXMuZmVhdHVyZXNbMF0pCn0KCgpmdW5jdGlvbiBkZWxldGVPdXRsaW5lRHJhd3MobWFwKSB7CiAgaWYgKGtleUluRGljdGlvbmFyeShtYXAuZ2V0U3R5bGUoKS5sYXllcnMsICdvdXRsaW5lJykpIHsKICAgIG1hcC5yZW1vdmVMYXllcignb3V0bGluZScpCiAgfQogIGlmICgnZHJhdycgaW4gbWFwLmdldFN0eWxlKCkuc291cmNlcykgewogICAgbWFwLnJlbW92ZVNvdXJjZSgnZHJhdycpCiAgfQp9CgoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICJUaHJlZWJveEV4YW1wbGUiLAogIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBhY2Nlc3NUb2tlbjoKICAgICAgICAicGsuZXlKMUlqb2libWxqYUc5c1lYTnRZWEowYVc1dklpd2lZU0k2SW1Ock1qVmhPR3BoT1RBelpHVXpiRzh3TkhKaGRUWnJNbVlpZlEuOTh1RE1uR0l2bjF6cnc0WldVTzM1ZyIsCiAgICB9OwogIH0sCiAgbW91bnRlZCgpIHsKICAgIHRoaXMuaW5pdE1hcCgpCiAgfSwKICBjb21wb25lbnRzOiB7CiAgICBSYW5nZVNsaWRlcgogIH0sCiAgbWV0aG9kczogewogICAgdXBkYXRlVmFsdWUodmFsdWUpIHsKICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlCiAgICAgIGNvbnNvbGUubG9nKCJWYWx1ZSB1cGRhdGVkIHRvIiwgdGhpcy52YWx1ZSkKICAgIH0sCiAgICBzcGhlcmUobG9uLCBsYXQpIHsKICAgICAgbGV0IG9yaWdpbiA9IFtsb24sIGxhdCwgMF07CiAgICAgIHJldHVybiB3aW5kb3cudGIKICAgICAgICAuc3BoZXJlKHsgY29sb3I6ICJyZWQiLCBtYXRlcmlhbDogIk1lc2hUb29uTWF0ZXJpYWwiIH0pCiAgICAgICAgLnNldENvb3JkcyhvcmlnaW4pOwogICAgfSwKICAgIGFuaW1hdGVQdWxzZSgpIHsKICAgICAgcHVsc2UudXBkYXRlKCk7CiAgICAgIHRoaXMubWFwLnRyaWdnZXJSZXBhaW50KCk7CiAgICB9LAogICAgaW5pdE1hcCgpIHsKICAgICAgbWFwYm94Z2wuYWNjZXNzVG9rZW4gPSB0aGlzLmFjY2Vzc1Rva2VuOwogICAgICB0aGlzLm1hcCA9IG5ldyBtYXBib3hnbC5NYXAoewogICAgICAgIGNvbnRhaW5lcjogIm1hcCIsCiAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsCiAgICAgICAgc3R5bGU6ICAibWFwYm94Oi8vc3R5bGVzL21hcGJveC9kYXJrLXYxMCIsCiAgICAgICAgem9vbTogMTYsCiAgICAgICAgY2VudGVyOiBbLTEyMy4xMDY4NjU4LCA0OS4yNjI2OTgyXSwKICAgICAgICBwaXRjaDogNjAsCiAgICAgICAgYmVhcmluZzogMzYwLAogICAgICAgIGFudGlhbGlhczogdHJ1ZSwKICAgICAgICAvLyBhdHRyaWJ1dGlvbkNvbnRyb2w6IGZhbHNlCiAgICAgIH0pLm9uKCJzdHlsZS5sb2FkIiwgKCkgPT4gewogICAgICAgIHdpbmRvdy50YiA9IG5ldyBUaHJlZWJveCgKICAgICAgICAgIHRoaXMubWFwLAogICAgICAgICAgdGhpcy5tYXAuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgid2ViZ2wiKSwKICAgICAgICAgIHsKICAgICAgICAgICAgZGVmYXVsdExpZ2h0czogdHJ1ZSwKICAgICAgICAgIH0KICAgICAgICApOwoKICAgICAgICAvLyBBZGQgZHJhdyBjb250cm9sCiAgICAgICAgaWYgKHRoaXMubWFwLmdldExheWVyKCJjdXN0b21fbGF5ZXIiKSA9PSBudWxsKSB7CgogICAgICAgICAgdGhpcy5tYXAub24oJ2xvYWQnLCAoKSA9PiB7CgogICAgICAgICAgICAvLyAvLyBBZGQgM0QgdGVycmFpbgogICAgICAgICAgICAvLyB0aGlzLm1hcC5hZGRTb3VyY2UoJ21hcGJveC1kZW0nLCB7CiAgICAgICAgICAgIC8vICAgJ3R5cGUnOiAncmFzdGVyLWRlbScsCiAgICAgICAgICAgIC8vICAgJ3VybCc6ICdtYXBib3g6Ly9tYXBib3gubWFwYm94LXRlcnJhaW4tZGVtLXYxJywKICAgICAgICAgICAgLy8gICAndGlsZVNpemUnOiA1MTIsCiAgICAgICAgICAgIC8vICAgJ21heHpvb20nOiAyMAogICAgICAgICAgICAvLyB9KTsKICAgICAgICAgICAgLy8KICAgICAgICAgICAgLy8gLy8gYWRkIHRoZSBERU0gc291cmNlIGFzIGEgdGVycmFpbiBsYXllciB3aXRoIGV4YWdnZXJhdGVkIGhlaWdodAogICAgICAgICAgICAvLyB0aGlzLm1hcC5zZXRUZXJyYWluKHsgJ3NvdXJjZSc6ICdtYXBib3gtZGVtJywgJ2V4YWdnZXJhdGlvbic6IDEuNSB9KTsKCiAgICAgICAgICAgIC8vIC8vIEFkZCBwYXJjZWxzIGxheWVyIHNvdXJjZSAoQ29WKQogICAgICAgICAgICAvLyB0aGlzLm1hcC5hZGRTb3VyY2UoJ3Byb3BlcnR5LXBhcmNlbC1wb2x5Z29ucycsIHsKICAgICAgICAgICAgLy8gICAndHlwZSc6ICdnZW9qc29uJywKICAgICAgICAgICAgLy8gICAnZGF0YSc6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vbmljaG9sYXNtYXJ0aW5vL3Z1ZS10aHJlZWJveC9tYXN0ZXIvcHVibGljL2RhdGEvcHJvcGVydHktcGFyY2VsLXBvbHlnb25zLmdlb2pzb24nLAogICAgICAgICAgICAvLyB9KTsKICAgICAgICAgICAgLy8KICAgICAgICAgICAgLy8gLy8gQWRkIHBhcmNlbHMgbGF5ZXIgdG8gbWFwCiAgICAgICAgICAgIC8vIHRoaXMubWFwLmFkZExheWVyKHsKICAgICAgICAgICAgLy8gICAnaWQnOiAncHJvcGVydHktcGFyY2VsLXBvbHlnb25zLXNocCcsCiAgICAgICAgICAgIC8vICAgJ3R5cGUnOiAnZmlsbCcsCiAgICAgICAgICAgIC8vICAgJ3NvdXJjZSc6ICdwcm9wZXJ0eS1wYXJjZWwtcG9seWdvbnMnLAogICAgICAgICAgICAvLyAgICdwYWludCc6IHsKICAgICAgICAgICAgLy8gICAgICdmaWxsLWNvbG9yJzogJyMwMDgwZmYnLCAvLyBibHVlIGNvbG9yIGZpbGwKICAgICAgICAgICAgLy8gICAgICdmaWxsLW9wYWNpdHknOiAwLjIsCiAgICAgICAgICAgIC8vICAgfSwKICAgICAgICAgICAgLy8gfSk7CgogICAgICAgICAgICAvLyBUaGUgJ2J1aWxkaW5nJyBsYXllciBpbiB0aGUgTWFwYm94IFN0cmVldHMKICAgICAgICAgICAgLy8gdmVjdG9yIHRpbGVzZXQgY29udGFpbnMgYnVpbGRpbmcgaGVpZ2h0IGRhdGEKICAgICAgICAgICAgLy8gZnJvbSBPcGVuU3RyZWV0TWFwLgogICAgICAgICAgICB0aGlzLm1hcC5hZGRMYXllcih7CiAgICAgICAgICAgICAgJ2lkJzogJ2FkZC0zZC1idWlsZGluZ3MnLAogICAgICAgICAgICAgICdzb3VyY2UnOiAnY29tcG9zaXRlJywKICAgICAgICAgICAgICAnc291cmNlLWxheWVyJzogJ2J1aWxkaW5nJywKICAgICAgICAgICAgICAnZmlsdGVyJzogWyc9PScsICdleHRydWRlJywgJ3RydWUnXSwKICAgICAgICAgICAgICAndHlwZSc6ICdmaWxsLWV4dHJ1c2lvbicsCiAgICAgICAgICAgICAgJ21pbnpvb20nOiAxMiwKICAgICAgICAgICAgICAncGFpbnQnOiB7CiAgICAgICAgICAgICAgICAnZmlsbC1leHRydXNpb24tY29sb3InOiAnI2FhYScsCgogICAgICAgICAgICAgICAgLy8gVXNlIGFuICdpbnRlcnBvbGF0ZScgZXhwcmVzc2lvbiB0bwogICAgICAgICAgICAgICAgLy8gYWRkIGEgc21vb3RoIHRyYW5zaXRpb24gZWZmZWN0IHRvCiAgICAgICAgICAgICAgICAvLyB0aGUgYnVpbGRpbmdzIGFzIHRoZSB1c2VyIHpvb21zIGluLgogICAgICAgICAgICAgICAgJ2ZpbGwtZXh0cnVzaW9uLWhlaWdodCc6IFsKICAgICAgICAgICAgICAgICAgJ2ludGVycG9sYXRlJywKICAgICAgICAgICAgICAgICAgWydsaW5lYXInXSwKICAgICAgICAgICAgICAgICAgWyd6b29tJ10sCiAgICAgICAgICAgICAgICAgIDksCiAgICAgICAgICAgICAgICAgIDAsCiAgICAgICAgICAgICAgICAgIDE1LjA1LAogICAgICAgICAgICAgICAgICBbJ2dldCcsICdoZWlnaHQnXQogICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICdmaWxsLWV4dHJ1c2lvbi1iYXNlJzogWwogICAgICAgICAgICAgICAgICAnaW50ZXJwb2xhdGUnLAogICAgICAgICAgICAgICAgICBbJ2xpbmVhciddLAogICAgICAgICAgICAgICAgICBbJ3pvb20nXSwKICAgICAgICAgICAgICAgICAgOSwKICAgICAgICAgICAgICAgICAgMCwKICAgICAgICAgICAgICAgICAgMTUuMDUsCiAgICAgICAgICAgICAgICAgIFsnZ2V0JywgJ21pbl9oZWlnaHQnXQogICAgICAgICAgICAgICAgXSwKCiAgICAgICAgICAgICAgICAvLyAnZmlsbC1leHRydXNpb24taGVpZ2h0JzogWydnZXQnLCAnaGVpZ2h0J10sCiAgICAgICAgICAgICAgICAnZmlsbC1leHRydXNpb24tb3BhY2l0eSc6IDAuOCwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGNvbnNvbGUubG9nKCJNYXAgb24gbG9hZCwgcmVzZXQgYW5kIHVwZGF0ZSBtYXJrZXJzOiIsIHRoaXMubWFya2VycykKCiAgICAgICAgICB9KTsKCiAgICAgICAgICAvLyAvLyBBZGQgc3BoZXJlcyB0byBtYXAKICAgICAgICAgIC8vIGNvbnN0IF90aGlzID0gdGhpcwogICAgICAgICAgLy8gdGhpcy5tYXAuYWRkTGF5ZXIoewogICAgICAgICAgLy8gICBpZDogImN1c3RvbV9sYXllciIsCiAgICAgICAgICAvLyAgIHR5cGU6ICJjdXN0b20iLAogICAgICAgICAgLy8gICByZW5kZXJpbmdNb2RlOiAiM2QiLAogICAgICAgICAgLy8KICAgICAgICAgIC8vICAgb25BZGQ6IGZ1bmN0aW9uIChtYXAsIG1ieENvbnRleHQpIHsKICAgICAgICAgIC8vICAgICB3aW5kb3cudGIuYWRkKF90aGlzLnNwaGVyZSgtMTIzLjEwNjg2NTgsIDQ5LjI2MjY5ODIpKTsKICAgICAgICAgIC8vICAgICB3aW5kb3cudGIuYWRkKF90aGlzLnNwaGVyZSgtMTIzLjEwODg2NTgsIDQ5LjI2MjY5ODIpKTsKICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhtYXApCiAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2cobWJ4Q29udGV4dCkKICAgICAgICAgIC8vICAgICBsZXQgcHVsc2VPYmogPSB3aW5kb3cudGIKICAgICAgICAgIC8vICAgICAgIC5PYmplY3QzRCh7IG9iajogcHVsc2UsIHVuaXRzOiAibWV0ZXJzIiB9KQogICAgICAgICAgLy8gICAgICAgLnNldENvb3JkcyhbLTEyMy4xMDY4NjU4LCA0OS4yNjI2OTgyLCAwXSk7CiAgICAgICAgICAvLwogICAgICAgICAgLy8gICAgIHB1bHNlT2JqLnNldEFuY2hvcigiYm90dG9tLWxlZnQiKTsKICAgICAgICAgIC8vCiAgICAgICAgICAvLyAgICAgd2luZG93LnRiLmFkZChwdWxzZU9iaik7CiAgICAgICAgICAvLyAgIH0sCiAgICAgICAgICAvLyAgIHJlbmRlcjogZnVuY3Rpb24gKGdsLCBtYXRyaXgpIHsKICAgICAgICAgIC8vICAgICB3aW5kb3cudGIudXBkYXRlKCk7CiAgICAgICAgICAvLyAgICAgX3RoaXMuYW5pbWF0ZVB1bHNlKCk7CiAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coZ2wpCiAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2cobWF0cml4KQogICAgICAgICAgLy8gICB9LAogICAgICAgICAgLy8gfSk7CgogICAgICAgIH0KCiAgICAgIH0pOwoKICAgICAgLy8gQWRkIGRyYXcgY29udHJvbHMKICAgICAgY29uc3QgZHJhdyA9IG5ldyBNYXBib3hEcmF3KCk7CiAgICAgIHRoaXMubWFwLmFkZENvbnRyb2woZHJhdywgJ3RvcC1yaWdodCcpOwoKICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGRyYXduIHBvbHlnb25zCiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUFyZWEoKSB7CiAgICAgICAgICBjb25zdCBkYXRhID0gZHJhdy5nZXRBbGwoKTsKICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWxjdWxhdGVkLWFyZWEnKTsKICAgICAgICAgIGlmIChkYXRhLmZlYXR1cmVzLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgY29uc3QgYXJlYSA9IHR1cmYuYXJlYShkYXRhKTsKCiAgICAgICAgICAgIC8vIFJlc3RyaWN0IHRoZSBhcmVhIHRvIDIgZGVjaW1hbCBwb2ludHMuCiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWRfYXJlYSA9IE1hdGgucm91bmQoYXJlYSAqIDEwMCkgLyAxMDA7CiAgICAgICAgICAgIGFuc3dlci5pbm5lckhUTUwgPSBgPHA+PHN0cm9uZz4ke3JvdW5kZWRfYXJlYX08L3N0cm9uZz4gbcKyPC9wPmA7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBhbnN3ZXIuaW5uZXJIVE1MID0gJyc7CiAgICAgICAgICAgIC8vIGlmIChlLnR5cGUgIT09ICdkcmF3LmRlbGV0ZScpCiAgICAgICAgICAgIC8vICAgYWxlcnQoJ0NsaWNrIHRoZSBtYXAgdG8gZHJhdyBhIHBvbHlnb24uJyk7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLm1hcC5vbignZHJhdy5jcmVhdGUnLCB1cGRhdGVBcmVhKTsKICAgICAgdGhpcy5tYXAub24oJ2RyYXcuZGVsZXRlJywgdXBkYXRlQXJlYSk7CiAgICAgIHRoaXMubWFwLm9uKCdkcmF3LnVwZGF0ZScsIHVwZGF0ZUFyZWEpOwoKICAgICAgdGhpcy5tYXAub24oJ2RyYXcuY3JlYXRlJywgKCkgPT4gewogICAgICAgIHRoaXMubWFwLmFkZFNvdXJjZSgnZHJhdycsIHsKICAgICAgICAgICd0eXBlJzogJ2dlb2pzb24nLAogICAgICAgICAgJ2RhdGEnOiBnZW5lcmF0ZUJsb2NrcyhkcmF3LCA4KSwKICAgICAgICB9KTsKICAgICAgICB0aGlzLm1hcC5hZGRMYXllcih7CiAgICAgICAgICAnaWQnOiAnb3V0bGluZScsCiAgICAgICAgICAndHlwZSc6ICdmaWxsJywKICAgICAgICAgICdzb3VyY2UnOiAnZHJhdycsCiAgICAgICAgICAncGFpbnQnOiB7CiAgICAgICAgICAgICdmaWxsLWNvbG9yJzogJyMwNmJlN2YnLAogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9KTsKCiAgICAgIHRoaXMubWFwLm9uKCdkcmF3LmRlbGV0ZScsICgpID0+IHsKICAgICAgICBkZWxldGVPdXRsaW5lRHJhd3ModGhpcy5tYXApCiAgICAgIH0pOwoKICAgICAgdGhpcy5tYXAub24oJ2RyYXcudXBkYXRlJywgKCkgPT4gewogICAgICAgIGRlbGV0ZU91dGxpbmVEcmF3cyh0aGlzLm1hcCkKICAgICAgICB0aGlzLm1hcC5hZGRTb3VyY2UoJ2RyYXcnLCB7CiAgICAgICAgICAndHlwZSc6ICdnZW9qc29uJywKICAgICAgICAgICdkYXRhJzogZ2VuZXJhdGVCbG9ja3MoZHJhdywgOCksCiAgICAgICAgfSk7CiAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIoewogICAgICAgICAgJ2lkJzogJ291dGxpbmUnLAogICAgICAgICAgJ3R5cGUnOiAnZmlsbCcsCiAgICAgICAgICAnc291cmNlJzogJ2RyYXcnLAogICAgICAgICAgJ3BhaW50JzogewogICAgICAgICAgICAnZmlsbC1jb2xvcic6ICcjMDZiZTdmJyAvLyByZWQgY29sb3IKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfSk7CgogICAgfSwKICB9LAp9OwoK"},{"version":3,"sources":["ThreeboxExample.vue"],"names":[],"mappings":";;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA","file":"ThreeboxExample.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div>\n    <div id=\"map\"></div>\n    <div id=\"vue-range-slider\">\n      <RangeSlider v-on:changeValue=\"updateValue($event)\"/>\n    </div>\n  </div>\n</template>\n\n<script>\nimport mapboxgl from \"mapbox-gl\";\nimport * as MapboxDraw from 'mapbox-gl-draw';\nimport threebox from \"threebox-plugin/dist/threebox\";\nimport { Threebox } from 'threebox-plugin';\nimport Pulse from \"./Pulses/Pulse\";\nimport * as turf from '@turf/turf';\nimport RangeSlider from \"./RangeSlider\"\n\n\nlet pulse = new Pulse(400, 4000, true);\nthreebox\n\n\n// Returns true if finds a defined key in the input array of dictionaries\nfunction keyInDictionary (dictionaries, keyToFind) {\n    for (var i in dictionaries) {\n        if (dictionaries[i]['id'] == keyToFind) {\n            return true\n        }\n    }\n}\n\n\n// Returns a list of centroids of multiple LineStrings\nfunction lineCentroids(lines) {\n  const centroids = [];\n  for (let i = 0; i < lines.features.length; i++) {\n    const line = turf.lineString(lines.features[i])\n    const ctr = turf.centroid(line['geometry']['coordinates'])\n    centroids.push(ctr)\n  }\n  return centroids\n}\n\n\n// Returns points along a LineString divided according to a specified length in meters\nfunction divideLineString(line, length=100) {\n  const chunks = turf.lineChunk(line, length, {units: 'meters'})\n  return lineCentroids(chunks)\n}\n\n\n// Extract drawn shape and convert it to a polygon\nfunction getPolygonDrawn(draw){\n  const data = draw.getAll()\n  return turf.polygon(data.features[0]['geometry']['coordinates'])\n}\n\n\n// Extract internal skeleton of a shape\nfunction voronoiSkeleton(draw){\n  const pol = getPolygonDrawn(draw)\n  const line = turf.polygonToLine(pol)\n  const chunks = turf.lineChunk(line, 0.01)\n  const centroids = lineCentroids(chunks)\n  const centroids_gj = {\n    \"type\": \"FeatureCollection\",\n    \"features\": centroids\n  }\n  const voronoi = turf.voronoi(centroids_gj)\n  // Iterate over voronoi polygons to extract segments inside drawing\n  const voronoiLines = [];\n  for (let i = 0; i < voronoi.features.length; i++) {\n    const voronoiPolygon = turf.polygon(voronoi.features[i]['geometry']['coordinates']);\n    const voronoiLine = turf.polygonToLine(voronoiPolygon)\n    const voronoiSegments = turf.lineSegment(voronoiLine)\n    for (let i = 0; i < voronoiSegments.features.length; i++) {\n      const segmentCentroid = turf.centroid(voronoiSegments.features[i])\n      if (turf.booleanContains(pol, segmentCentroid)) {\n        voronoiLines.push(voronoiSegments.features[i])\n      }\n    }\n  }\n  const voronoiLinesGeoJSON = {\n    \"type\": \"FeatureCollection\",\n    \"features\": voronoiLines\n  }\n  const voronoiLinesCombined = turf.combine(voronoiLinesGeoJSON)\n  const voronoiLinesSimplified = turf.simplify(voronoiLinesCombined,\n    {tolerance: 5, mutate: true})\n  return voronoiLinesSimplified\n}\n\n\n// Generate skeleton and buffer according to some number of iterations\nfunction bufferDrawSkeleton(skeleton) {\n  const bufferedSkeletons = []\n  for (let i = 0; i < 3; i++) {\n    const skeletonBuffer = turf.buffer(skeleton, 30 * (i+1), {units: 'meters'})\n    const dissolvedSkeleton = turf.dissolve(skeletonBuffer)\n    bufferedSkeletons.push(turf.lineString(dissolvedSkeleton.features[0]['geometry']['coordinates'][0]))\n  }\n  return bufferedSkeletons\n}\n\n\n// Subdivide a drawn shape using Voronoi patterns\nfunction subdivideShape(draw) {\n  const skeleton = voronoiSkeleton(draw)\n  const skeletonBufferSmall = turf.buffer(skeleton, 0.1, {units: 'meters'}).features[0]\n  const skeletonLine = turf.polygonToLine(skeletonBufferSmall)\n  const dividedSkeleton = divideLineString(turf.combine(skeletonLine))\n  const voronoiSkeletonBuffers = bufferDrawSkeleton(skeleton)\n  const perpendicularLines = []\n  for (let i = 0; i < dividedSkeleton.length; i++) {\n    var originalPoint = dividedSkeleton[i]\n    const nearestPoints = [originalPoint['geometry']['coordinates']]\n    for (let j = 0; j < voronoiSkeletonBuffers.length; j++) {\n      const buffer = voronoiSkeletonBuffers[j]\n      const nextPoint = turf.nearestPointOnLine(buffer, turf.point(originalPoint['geometry']['coordinates']))\n      nearestPoints.push(nextPoint['geometry']['coordinates'])\n      originalPoint = nextPoint\n    }\n    perpendicularLines.push(turf.lineString(nearestPoints))\n  }\n  // Buffer lines and subtract\n  const centerlines = turf.featureCollection(perpendicularLines.concat(skeleton.features, voronoiSkeletonBuffers))\n  return centerlines\n}\n\n\nfunction generateBlocks(draw, street_width) {\n  const bufferedCenterlines = turf.dissolve(turf.buffer(subdivideShape(draw), street_width/2, {units: 'meters'}))\n  return turf.difference(getPolygonDrawn(draw), bufferedCenterlines.features[0])\n}\n\n\nfunction deleteOutlineDraws(map) {\n  if (keyInDictionary(map.getStyle().layers, 'outline')) {\n    map.removeLayer('outline')\n  }\n  if ('draw' in map.getStyle().sources) {\n    map.removeSource('draw')\n  }\n}\n\n\nexport default {\n  name: \"ThreeboxExample\",\n  data() {\n    return {\n      accessToken:\n        \"pk.eyJ1IjoibmljaG9sYXNtYXJ0aW5vIiwiYSI6ImNrMjVhOGphOTAzZGUzbG8wNHJhdTZrMmYifQ.98uDMnGIvn1zrw4ZWUO35g\",\n    };\n  },\n  mounted() {\n    this.initMap()\n  },\n  components: {\n    RangeSlider\n  },\n  methods: {\n    updateValue(value) {\n      this.value = value\n      console.log(\"Value updated to\", this.value)\n    },\n    sphere(lon, lat) {\n      let origin = [lon, lat, 0];\n      return window.tb\n        .sphere({ color: \"red\", material: \"MeshToonMaterial\" })\n        .setCoords(origin);\n    },\n    animatePulse() {\n      pulse.update();\n      this.map.triggerRepaint();\n    },\n    initMap() {\n      mapboxgl.accessToken = this.accessToken;\n      this.map = new mapboxgl.Map({\n        container: \"map\",\n        interactive: true,\n        style:  \"mapbox://styles/mapbox/dark-v10\",\n        zoom: 16,\n        center: [-123.1068658, 49.2626982],\n        pitch: 60,\n        bearing: 360,\n        antialias: true,\n        // attributionControl: false\n      }).on(\"style.load\", () => {\n        window.tb = new Threebox(\n          this.map,\n          this.map.getCanvas().getContext(\"webgl\"),\n          {\n            defaultLights: true,\n          }\n        );\n\n        // Add draw control\n        if (this.map.getLayer(\"custom_layer\") == null) {\n\n          this.map.on('load', () => {\n\n            // // Add 3D terrain\n            // this.map.addSource('mapbox-dem', {\n            //   'type': 'raster-dem',\n            //   'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',\n            //   'tileSize': 512,\n            //   'maxzoom': 20\n            // });\n            //\n            // // add the DEM source as a terrain layer with exaggerated height\n            // this.map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });\n\n            // // Add parcels layer source (CoV)\n            // this.map.addSource('property-parcel-polygons', {\n            //   'type': 'geojson',\n            //   'data': 'https://raw.githubusercontent.com/nicholasmartino/vue-threebox/master/public/data/property-parcel-polygons.geojson',\n            // });\n            //\n            // // Add parcels layer to map\n            // this.map.addLayer({\n            //   'id': 'property-parcel-polygons-shp',\n            //   'type': 'fill',\n            //   'source': 'property-parcel-polygons',\n            //   'paint': {\n            //     'fill-color': '#0080ff', // blue color fill\n            //     'fill-opacity': 0.2,\n            //   },\n            // });\n\n            // The 'building' layer in the Mapbox Streets\n            // vector tileset contains building height data\n            // from OpenStreetMap.\n            this.map.addLayer({\n              'id': 'add-3d-buildings',\n              'source': 'composite',\n              'source-layer': 'building',\n              'filter': ['==', 'extrude', 'true'],\n              'type': 'fill-extrusion',\n              'minzoom': 12,\n              'paint': {\n                'fill-extrusion-color': '#aaa',\n\n                // Use an 'interpolate' expression to\n                // add a smooth transition effect to\n                // the buildings as the user zooms in.\n                'fill-extrusion-height': [\n                  'interpolate',\n                  ['linear'],\n                  ['zoom'],\n                  9,\n                  0,\n                  15.05,\n                  ['get', 'height']\n                ],\n                'fill-extrusion-base': [\n                  'interpolate',\n                  ['linear'],\n                  ['zoom'],\n                  9,\n                  0,\n                  15.05,\n                  ['get', 'min_height']\n                ],\n\n                // 'fill-extrusion-height': ['get', 'height'],\n                'fill-extrusion-opacity': 0.8,\n              },\n            });\n\n            console.log(\"Map on load, reset and update markers:\", this.markers)\n\n          });\n\n          // // Add spheres to map\n          // const _this = this\n          // this.map.addLayer({\n          //   id: \"custom_layer\",\n          //   type: \"custom\",\n          //   renderingMode: \"3d\",\n          //\n          //   onAdd: function (map, mbxContext) {\n          //     window.tb.add(_this.sphere(-123.1068658, 49.2626982));\n          //     window.tb.add(_this.sphere(-123.1088658, 49.2626982));\n          //     console.log(map)\n          //     console.log(mbxContext)\n          //     let pulseObj = window.tb\n          //       .Object3D({ obj: pulse, units: \"meters\" })\n          //       .setCoords([-123.1068658, 49.2626982, 0]);\n          //\n          //     pulseObj.setAnchor(\"bottom-left\");\n          //\n          //     window.tb.add(pulseObj);\n          //   },\n          //   render: function (gl, matrix) {\n          //     window.tb.update();\n          //     _this.animatePulse();\n          //     console.log(gl)\n          //     console.log(matrix)\n          //   },\n          // });\n\n        }\n\n      });\n\n      // Add draw controls\n      const draw = new MapboxDraw();\n      this.map.addControl(draw, 'top-right');\n\n      // Calculate the area of drawn polygons\n      function updateArea() {\n          const data = draw.getAll();\n          const answer = document.getElementById('calculated-area');\n          if (data.features.length > 0) {\n            const area = turf.area(data);\n\n            // Restrict the area to 2 decimal points.\n            const rounded_area = Math.round(area * 100) / 100;\n            answer.innerHTML = `<p><strong>${rounded_area}</strong> m²</p>`;\n          } else {\n            answer.innerHTML = '';\n            // if (e.type !== 'draw.delete')\n            //   alert('Click the map to draw a polygon.');\n        }\n      }\n\n      this.map.on('draw.create', updateArea);\n      this.map.on('draw.delete', updateArea);\n      this.map.on('draw.update', updateArea);\n\n      this.map.on('draw.create', () => {\n        this.map.addSource('draw', {\n          'type': 'geojson',\n          'data': generateBlocks(draw, 8),\n        });\n        this.map.addLayer({\n          'id': 'outline',\n          'type': 'fill',\n          'source': 'draw',\n          'paint': {\n            'fill-color': '#06be7f',\n          }\n        });\n      });\n\n      this.map.on('draw.delete', () => {\n        deleteOutlineDraws(this.map)\n      });\n\n      this.map.on('draw.update', () => {\n        deleteOutlineDraws(this.map)\n        this.map.addSource('draw', {\n          'type': 'geojson',\n          'data': generateBlocks(draw, 8),\n        });\n        this.map.addLayer({\n          'id': 'outline',\n          'type': 'fill',\n          'source': 'draw',\n          'paint': {\n            'fill-color': '#06be7f' // red color\n          }\n        });\n      });\n\n    },\n  },\n};\n\n</script>\n\n\n<style>\n#map {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n}\n@import \"https://api.mapbox.com/mapbox-gl-js/v0.42.0/mapbox-gl.css\";\n@import \"https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.2/mapbox-gl-draw.css\";\n@import \"https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.0/mapbox-gl.css\";\n.mapboxgl-ctrl-group button {\n    width: 29px;\n    height: 29px;\n    display: block;\n    padding: 0;\n    outline: none;\n    border: 0;\n    box-sizing: border-box;\n    background-color: transparent;\n    cursor: pointer;\n    overflow: hidden;\n}\n.mapboxgl-ctrl-top-right {\n    top: 0;\n    right: 0;\n    position: absolute;\n}\n.marker:before {\n  content: \"\";\n  cursor: pointer;\n  position: absolute;\n  width: 25px;\n  height: 25px;\n  border: 1px solid #ccc;\n  border-radius: 75% 45% 75% 0%;\n  background: #3498db;\n  bottom: 0;\n  transform-origin: 0% 100%;\n  transform: rotate(-45deg) scale(1);\n}\n</style>\n"]}]}