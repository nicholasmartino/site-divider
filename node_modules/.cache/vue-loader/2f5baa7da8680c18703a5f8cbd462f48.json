{"remainingRequest":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/node_modules/vue-loader/lib/index.js??vue-loader-options!/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/src/components/ThreeboxExample.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/src/components/ThreeboxExample.vue","mtime":1638923255000},{"path":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/node_modules/cache-loader/dist/cjs.js","mtime":1637704935000},{"path":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/node_modules/babel-loader/lib/index.js","mtime":1637705426000},{"path":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/node_modules/cache-loader/dist/cjs.js","mtime":1637704935000},{"path":"/Volumes/GoogleDrive/My Drive/JavaScript/vue-threebox-sample/node_modules/vue-loader/lib/index.js","mtime":1637705662000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBtYXBib3hnbCBmcm9tICJtYXBib3gtZ2wiOwppbXBvcnQgKiBhcyBNYXBib3hEcmF3IGZyb20gJ21hcGJveC1nbC1kcmF3JzsKaW1wb3J0IHRocmVlYm94IGZyb20gInRocmVlYm94LXBsdWdpbi9kaXN0L3RocmVlYm94IjsKaW1wb3J0IHsgVGhyZWVib3ggfSBmcm9tICd0aHJlZWJveC1wbHVnaW4nOwppbXBvcnQgUHVsc2UgZnJvbSAiLi9QdWxzZXMvUHVsc2UiOwppbXBvcnQgKiBhcyB0dXJmIGZyb20gJ0B0dXJmL3R1cmYnOwppbXBvcnQgUmFuZ2VTbGlkZXIgZnJvbSAiLi9SYW5nZVNsaWRlciIKaW1wb3J0IHsgbWFwU3RhdGUgfSBmcm9tICJ2dWV4IjsKCgpjb25zb2xlLmxvZyhtYXBTdGF0ZSkKbGV0IHB1bHNlID0gbmV3IFB1bHNlKDQwMCwgNDAwMCwgdHJ1ZSk7CnRocmVlYm94CgoKLy8gUmV0dXJucyB0cnVlIGlmIGZpbmRzIGEgZGVmaW5lZCBrZXkgaW4gdGhlIGlucHV0IGFycmF5IG9mIGRpY3Rpb25hcmllcwpmdW5jdGlvbiBrZXlJbkRpY3Rpb25hcnkgKGRpY3Rpb25hcmllcywga2V5VG9GaW5kKSB7CiAgICBmb3IgKHZhciBpIGluIGRpY3Rpb25hcmllcykgewogICAgICAgIGlmIChkaWN0aW9uYXJpZXNbaV1bJ2lkJ10gPT0ga2V5VG9GaW5kKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlCiAgICAgICAgfQogICAgfQp9CgoKLy8gUmV0dXJucyBhIGxpc3Qgb2YgY2VudHJvaWRzIG9mIG11bHRpcGxlIExpbmVTdHJpbmdzCmZ1bmN0aW9uIGxpbmVDZW50cm9pZHMobGluZXMpIHsKICBjb25zdCBjZW50cm9pZHMgPSBbXTsKICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7CiAgICBjb25zdCBsaW5lID0gdHVyZi5saW5lU3RyaW5nKGxpbmVzLmZlYXR1cmVzW2ldKQogICAgY29uc3QgY3RyID0gdHVyZi5jZW50cm9pZChsaW5lWydnZW9tZXRyeSddWydjb29yZGluYXRlcyddKQogICAgY2VudHJvaWRzLnB1c2goY3RyKQogIH0KICByZXR1cm4gY2VudHJvaWRzCn0KCgovLyBSZXR1cm5zIHBvaW50cyBhbG9uZyBhIExpbmVTdHJpbmcgZGl2aWRlZCBhY2NvcmRpbmcgdG8gYSBzcGVjaWZpZWQgbGVuZ3RoIGluIG1ldGVycwpmdW5jdGlvbiBkaXZpZGVMaW5lU3RyaW5nKGxpbmUsIGxlbmd0aD0xMDApIHsKICBjb25zdCBjaHVua3MgPSB0dXJmLmxpbmVDaHVuayhsaW5lLCBsZW5ndGgsIHt1bml0czogJ21ldGVycyd9KQogIHJldHVybiBsaW5lQ2VudHJvaWRzKGNodW5rcykKfQoKCi8vIEV4dHJhY3QgZHJhd24gc2hhcGUgYW5kIGNvbnZlcnQgaXQgdG8gYSBwb2x5Z29uCmZ1bmN0aW9uIGdldFBvbHlnb25EcmF3bihkcmF3KXsKICBjb25zdCBkYXRhID0gZHJhdy5nZXRBbGwoKQogIHJldHVybiB0dXJmLnBvbHlnb24oZGF0YS5mZWF0dXJlc1swXVsnZ2VvbWV0cnknXVsnY29vcmRpbmF0ZXMnXSkKfQoKCi8vIEV4dHJhY3QgaW50ZXJuYWwgc2tlbGV0b24gb2YgYSBzaGFwZQpmdW5jdGlvbiB2b3Jvbm9pU2tlbGV0b24oZHJhdyl7CiAgY29uc3QgcG9sID0gZ2V0UG9seWdvbkRyYXduKGRyYXcpCiAgY29uc3QgbGluZSA9IHR1cmYucG9seWdvblRvTGluZShwb2wpCiAgY29uc3QgY2h1bmtzID0gdHVyZi5saW5lQ2h1bmsobGluZSwgMC4wMSkKICBjb25zdCBjZW50cm9pZHMgPSBsaW5lQ2VudHJvaWRzKGNodW5rcykKICBjb25zdCBjZW50cm9pZHNfZ2ogPSB7CiAgICAidHlwZSI6ICJGZWF0dXJlQ29sbGVjdGlvbiIsCiAgICAiZmVhdHVyZXMiOiBjZW50cm9pZHMKICB9CiAgY29uc3Qgdm9yb25vaSA9IHR1cmYudm9yb25vaShjZW50cm9pZHNfZ2opCiAgLy8gSXRlcmF0ZSBvdmVyIHZvcm9ub2kgcG9seWdvbnMgdG8gZXh0cmFjdCBzZWdtZW50cyBpbnNpZGUgZHJhd2luZwogIGNvbnN0IHZvcm9ub2lMaW5lcyA9IFtdOwogIGZvciAobGV0IGkgPSAwOyBpIDwgdm9yb25vaS5mZWF0dXJlcy5sZW5ndGg7IGkrKykgewogICAgY29uc3Qgdm9yb25vaVBvbHlnb24gPSB0dXJmLnBvbHlnb24odm9yb25vaS5mZWF0dXJlc1tpXVsnZ2VvbWV0cnknXVsnY29vcmRpbmF0ZXMnXSk7CiAgICBjb25zdCB2b3Jvbm9pTGluZSA9IHR1cmYucG9seWdvblRvTGluZSh2b3Jvbm9pUG9seWdvbikKICAgIGNvbnN0IHZvcm9ub2lTZWdtZW50cyA9IHR1cmYubGluZVNlZ21lbnQodm9yb25vaUxpbmUpCiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZvcm9ub2lTZWdtZW50cy5mZWF0dXJlcy5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBzZWdtZW50Q2VudHJvaWQgPSB0dXJmLmNlbnRyb2lkKHZvcm9ub2lTZWdtZW50cy5mZWF0dXJlc1tpXSkKICAgICAgaWYgKHR1cmYuYm9vbGVhbkNvbnRhaW5zKHBvbCwgc2VnbWVudENlbnRyb2lkKSkgewogICAgICAgIHZvcm9ub2lMaW5lcy5wdXNoKHZvcm9ub2lTZWdtZW50cy5mZWF0dXJlc1tpXSkKICAgICAgfQogICAgfQogIH0KICBjb25zdCB2b3Jvbm9pTGluZXNHZW9KU09OID0gewogICAgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24iLAogICAgImZlYXR1cmVzIjogdm9yb25vaUxpbmVzCiAgfQogIGNvbnN0IHZvcm9ub2lMaW5lc0NvbWJpbmVkID0gdHVyZi5jb21iaW5lKHZvcm9ub2lMaW5lc0dlb0pTT04pCiAgY29uc3Qgdm9yb25vaUxpbmVzU2ltcGxpZmllZCA9IHR1cmYuc2ltcGxpZnkodm9yb25vaUxpbmVzQ29tYmluZWQsCiAgICB7dG9sZXJhbmNlOiA1LCBtdXRhdGU6IHRydWV9KQogIHJldHVybiB2b3Jvbm9pTGluZXNTaW1wbGlmaWVkCn0KCgovLyBHZW5lcmF0ZSBza2VsZXRvbiBhbmQgYnVmZmVyIGFjY29yZGluZyB0byBzb21lIG51bWJlciBvZiBpdGVyYXRpb25zCmZ1bmN0aW9uIGJ1ZmZlckRyYXdTa2VsZXRvbihza2VsZXRvbikgewogIGNvbnN0IGJ1ZmZlcmVkU2tlbGV0b25zID0gW10KICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykgewogICAgY29uc3Qgc2tlbGV0b25CdWZmZXIgPSB0dXJmLmJ1ZmZlcihza2VsZXRvbiwgMzAgKiAoaSsxKSwge3VuaXRzOiAnbWV0ZXJzJ30pCiAgICBjb25zdCBkaXNzb2x2ZWRTa2VsZXRvbiA9IHR1cmYuZGlzc29sdmUoc2tlbGV0b25CdWZmZXIpCiAgICBidWZmZXJlZFNrZWxldG9ucy5wdXNoKHR1cmYubGluZVN0cmluZyhkaXNzb2x2ZWRTa2VsZXRvbi5mZWF0dXJlc1swXVsnZ2VvbWV0cnknXVsnY29vcmRpbmF0ZXMnXVswXSkpCiAgfQogIHJldHVybiBidWZmZXJlZFNrZWxldG9ucwp9CgoKLy8gU3ViZGl2aWRlIGEgZHJhd24gc2hhcGUgdXNpbmcgVm9yb25vaSBwYXR0ZXJucwpmdW5jdGlvbiBzdWJkaXZpZGVTaGFwZShkcmF3KSB7CiAgY29uc3Qgc2tlbGV0b24gPSB2b3Jvbm9pU2tlbGV0b24oZHJhdykKICBjb25zdCBza2VsZXRvbkJ1ZmZlclNtYWxsID0gdHVyZi5idWZmZXIoc2tlbGV0b24sIDAuMSwge3VuaXRzOiAnbWV0ZXJzJ30pLmZlYXR1cmVzWzBdCiAgY29uc3Qgc2tlbGV0b25MaW5lID0gdHVyZi5wb2x5Z29uVG9MaW5lKHNrZWxldG9uQnVmZmVyU21hbGwpCiAgY29uc3QgZGl2aWRlZFNrZWxldG9uID0gZGl2aWRlTGluZVN0cmluZyh0dXJmLmNvbWJpbmUoc2tlbGV0b25MaW5lKSkKICBjb25zdCB2b3Jvbm9pU2tlbGV0b25CdWZmZXJzID0gYnVmZmVyRHJhd1NrZWxldG9uKHNrZWxldG9uKQogIGNvbnN0IHBlcnBlbmRpY3VsYXJMaW5lcyA9IFtdCiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXZpZGVkU2tlbGV0b24ubGVuZ3RoOyBpKyspIHsKICAgIHZhciBvcmlnaW5hbFBvaW50ID0gZGl2aWRlZFNrZWxldG9uW2ldCiAgICBjb25zdCBuZWFyZXN0UG9pbnRzID0gW29yaWdpbmFsUG9pbnRbJ2dlb21ldHJ5J11bJ2Nvb3JkaW5hdGVzJ11dCiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZvcm9ub2lTa2VsZXRvbkJ1ZmZlcnMubGVuZ3RoOyBqKyspIHsKICAgICAgY29uc3QgYnVmZmVyID0gdm9yb25vaVNrZWxldG9uQnVmZmVyc1tqXQogICAgICBjb25zdCBuZXh0UG9pbnQgPSB0dXJmLm5lYXJlc3RQb2ludE9uTGluZShidWZmZXIsIHR1cmYucG9pbnQob3JpZ2luYWxQb2ludFsnZ2VvbWV0cnknXVsnY29vcmRpbmF0ZXMnXSkpCiAgICAgIG5lYXJlc3RQb2ludHMucHVzaChuZXh0UG9pbnRbJ2dlb21ldHJ5J11bJ2Nvb3JkaW5hdGVzJ10pCiAgICAgIG9yaWdpbmFsUG9pbnQgPSBuZXh0UG9pbnQKICAgIH0KICAgIHBlcnBlbmRpY3VsYXJMaW5lcy5wdXNoKHR1cmYubGluZVN0cmluZyhuZWFyZXN0UG9pbnRzKSkKICB9CiAgLy8gQnVmZmVyIGxpbmVzIGFuZCBzdWJ0cmFjdAogIGNvbnN0IGNlbnRlcmxpbmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihwZXJwZW5kaWN1bGFyTGluZXMuY29uY2F0KHNrZWxldG9uLmZlYXR1cmVzLCB2b3Jvbm9pU2tlbGV0b25CdWZmZXJzKSkKICByZXR1cm4gY2VudGVybGluZXMKfQoKCmZ1bmN0aW9uIGdlbmVyYXRlQmxvY2tzKGRyYXcsIHN0cmVldF93aWR0aCkgewogIGNvbnN0IGJ1ZmZlcmVkQ2VudGVybGluZXMgPSB0dXJmLmRpc3NvbHZlKHR1cmYuYnVmZmVyKHN1YmRpdmlkZVNoYXBlKGRyYXcpLCBzdHJlZXRfd2lkdGgvMiwge3VuaXRzOiAnbWV0ZXJzJ30pKQogIHJldHVybiB0dXJmLmRpZmZlcmVuY2UoZ2V0UG9seWdvbkRyYXduKGRyYXcpLCBidWZmZXJlZENlbnRlcmxpbmVzLmZlYXR1cmVzWzBdKQp9CgoKZnVuY3Rpb24gZGVsZXRlT3V0bGluZURyYXdzKG1hcCkgewogIGlmIChrZXlJbkRpY3Rpb25hcnkobWFwLmdldFN0eWxlKCkubGF5ZXJzLCAnb3V0bGluZScpKSB7CiAgICBtYXAucmVtb3ZlTGF5ZXIoJ291dGxpbmUnKQogIH0KICBpZiAoJ2RyYXcnIGluIG1hcC5nZXRTdHlsZSgpLnNvdXJjZXMpIHsKICAgIG1hcC5yZW1vdmVTb3VyY2UoJ2RyYXcnKQogIH0KfQoKCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAiVGhyZWVib3hFeGFtcGxlIiwKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgYWNjZXNzVG9rZW46CiAgICAgICAgInBrLmV5SjFJam9pYm1samFHOXNZWE50WVhKMGFXNXZJaXdpWVNJNkltTnJNalZoT0dwaE9UQXpaR1V6Ykc4d05ISmhkVFpyTW1ZaWZRLjk4dURNbkdJdm4xenJ3NFpXVU8zNWciLAogICAgICB2YWx1ZTogbnVsbCwKICAgICAgZHJhd2luZzogbnVsbCwKICAgICAgbWFya2VyczogW10KICAgIH07CiAgfSwKICBtb3VudGVkKCkgewogICAgdGhpcy5pbml0TWFwKCkKICB9LAogIGNvbXBvbmVudHM6IHsKICAgIFJhbmdlU2xpZGVyCiAgfSwKICBjb21wdXRlZDogewogIC4uLm1hcFN0YXRlKFsiY3VycmVudEZlYXR1cmVzIl0pLAogIH0sCiAgd2F0Y2g6IHsKICAgIGN1cnJlbnRGZWF0dXJlczogewogICAgICBoYW5kbGVyKCkgewogICAgICAgIGlmICh0aGlzLmN1cnJlbnRGZWF0dXJlcykgewogICAgICAgICAgdGhpcy5yZXNldE1hcmtlcnMoKTsKICAgICAgICAgIHRoaXMudXBkYXRlTWFya2VycygpOwogICAgICAgICAgY29uc29sZS5sb2codGhpcy5jdXJyZW50RmVhdHVyZXMpCgogICAgICAgIH0KICAgICAgfSwKICAgICAgZGVlcDogdHJ1ZSwKICAgIH0sCiAgfSwKICBtZXRob2RzOiB7CiAgICB1cGRhdGVWYWx1ZSh2YWx1ZSkgewogICAgICB0aGlzLnZhbHVlID0gdmFsdWUKICAgICAgY29uc29sZS5sb2coIlZhbHVlIHVwZGF0ZWQgdG8iLCB0aGlzLnZhbHVlKQogICAgfSwKICAgIHNwaGVyZShsb24sIGxhdCkgewogICAgICBsZXQgb3JpZ2luID0gW2xvbiwgbGF0LCAwXTsKICAgICAgcmV0dXJuIHdpbmRvdy50YgogICAgICAgIC5zcGhlcmUoeyBjb2xvcjogInJlZCIsIG1hdGVyaWFsOiAiTWVzaFRvb25NYXRlcmlhbCIgfSkKICAgICAgICAuc2V0Q29vcmRzKG9yaWdpbik7CiAgICB9LAogICAgYW5pbWF0ZVB1bHNlKCkgewogICAgICBwdWxzZS51cGRhdGUoKTsKICAgICAgdGhpcy5tYXAudHJpZ2dlclJlcGFpbnQoKTsKICAgIH0sCiAgICBpbml0TWFwKCkgewogICAgICBtYXBib3hnbC5hY2Nlc3NUb2tlbiA9IHRoaXMuYWNjZXNzVG9rZW47CiAgICAgIHRoaXMubWFwID0gbmV3IG1hcGJveGdsLk1hcCh7CiAgICAgICAgY29udGFpbmVyOiAibWFwIiwKICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSwKICAgICAgICBzdHlsZTogICJtYXBib3g6Ly9zdHlsZXMvbWFwYm94L2RhcmstdjEwIiwKICAgICAgICB6b29tOiAxNiwKICAgICAgICBjZW50ZXI6IFstMTIzLjEwNjg2NTgsIDQ5LjI2MjY5ODJdLAogICAgICAgIHBpdGNoOiA2MCwKICAgICAgICBiZWFyaW5nOiAzNjAsCiAgICAgICAgYW50aWFsaWFzOiB0cnVlLAogICAgICAgIC8vIGF0dHJpYnV0aW9uQ29udHJvbDogZmFsc2UKICAgICAgfSkub24oInN0eWxlLmxvYWQiLCAoKSA9PiB7CiAgICAgICAgd2luZG93LnRiID0gbmV3IFRocmVlYm94KAogICAgICAgICAgdGhpcy5tYXAsCiAgICAgICAgICB0aGlzLm1hcC5nZXRDYW52YXMoKS5nZXRDb250ZXh0KCJ3ZWJnbCIpLAogICAgICAgICAgewogICAgICAgICAgICBkZWZhdWx0TGlnaHRzOiB0cnVlLAogICAgICAgICAgfQogICAgICAgICk7CgogICAgICAgIC8vIEFkZCBkcmF3IGNvbnRyb2wKICAgICAgICBpZiAodGhpcy5tYXAuZ2V0TGF5ZXIoImN1c3RvbV9sYXllciIpID09IG51bGwpIHsKCiAgICAgICAgICB0aGlzLm1hcC5vbignbG9hZCcsICgpID0+IHsKCiAgICAgICAgICAgIC8vIC8vIEFkZCAzRCB0ZXJyYWluCiAgICAgICAgICAgIC8vIHRoaXMubWFwLmFkZFNvdXJjZSgnbWFwYm94LWRlbScsIHsKICAgICAgICAgICAgLy8gICAndHlwZSc6ICdyYXN0ZXItZGVtJywKICAgICAgICAgICAgLy8gICAndXJsJzogJ21hcGJveDovL21hcGJveC5tYXBib3gtdGVycmFpbi1kZW0tdjEnLAogICAgICAgICAgICAvLyAgICd0aWxlU2l6ZSc6IDUxMiwKICAgICAgICAgICAgLy8gICAnbWF4em9vbSc6IDIwCiAgICAgICAgICAgIC8vIH0pOwogICAgICAgICAgICAvLwogICAgICAgICAgICAvLyAvLyBhZGQgdGhlIERFTSBzb3VyY2UgYXMgYSB0ZXJyYWluIGxheWVyIHdpdGggZXhhZ2dlcmF0ZWQgaGVpZ2h0CiAgICAgICAgICAgIC8vIHRoaXMubWFwLnNldFRlcnJhaW4oeyAnc291cmNlJzogJ21hcGJveC1kZW0nLCAnZXhhZ2dlcmF0aW9uJzogMS41IH0pOwoKICAgICAgICAgICAgLy8gLy8gQWRkIHBhcmNlbHMgbGF5ZXIgc291cmNlIChDb1YpCiAgICAgICAgICAgIC8vIHRoaXMubWFwLmFkZFNvdXJjZSgncHJvcGVydHktcGFyY2VsLXBvbHlnb25zJywgewogICAgICAgICAgICAvLyAgICd0eXBlJzogJ2dlb2pzb24nLAogICAgICAgICAgICAvLyAgICdkYXRhJzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9uaWNob2xhc21hcnRpbm8vdnVlLXRocmVlYm94L21hc3Rlci9wdWJsaWMvZGF0YS9wcm9wZXJ0eS1wYXJjZWwtcG9seWdvbnMuZ2VvanNvbicsCiAgICAgICAgICAgIC8vIH0pOwogICAgICAgICAgICAvLwogICAgICAgICAgICAvLyAvLyBBZGQgcGFyY2VscyBsYXllciB0byBtYXAKICAgICAgICAgICAgLy8gdGhpcy5tYXAuYWRkTGF5ZXIoewogICAgICAgICAgICAvLyAgICdpZCc6ICdwcm9wZXJ0eS1wYXJjZWwtcG9seWdvbnMtc2hwJywKICAgICAgICAgICAgLy8gICAndHlwZSc6ICdmaWxsJywKICAgICAgICAgICAgLy8gICAnc291cmNlJzogJ3Byb3BlcnR5LXBhcmNlbC1wb2x5Z29ucycsCiAgICAgICAgICAgIC8vICAgJ3BhaW50JzogewogICAgICAgICAgICAvLyAgICAgJ2ZpbGwtY29sb3InOiAnIzAwODBmZicsIC8vIGJsdWUgY29sb3IgZmlsbAogICAgICAgICAgICAvLyAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuMiwKICAgICAgICAgICAgLy8gICB9LAogICAgICAgICAgICAvLyB9KTsKCiAgICAgICAgICAgIC8vIFRoZSAnYnVpbGRpbmcnIGxheWVyIGluIHRoZSBNYXBib3ggU3RyZWV0cwogICAgICAgICAgICAvLyB2ZWN0b3IgdGlsZXNldCBjb250YWlucyBidWlsZGluZyBoZWlnaHQgZGF0YQogICAgICAgICAgICAvLyBmcm9tIE9wZW5TdHJlZXRNYXAuCiAgICAgICAgICAgIHRoaXMubWFwLmFkZExheWVyKHsKICAgICAgICAgICAgICAnaWQnOiAnYWRkLTNkLWJ1aWxkaW5ncycsCiAgICAgICAgICAgICAgJ3NvdXJjZSc6ICdjb21wb3NpdGUnLAogICAgICAgICAgICAgICdzb3VyY2UtbGF5ZXInOiAnYnVpbGRpbmcnLAogICAgICAgICAgICAgICdmaWx0ZXInOiBbJz09JywgJ2V4dHJ1ZGUnLCAndHJ1ZSddLAogICAgICAgICAgICAgICd0eXBlJzogJ2ZpbGwtZXh0cnVzaW9uJywKICAgICAgICAgICAgICAnbWluem9vbSc6IDEyLAogICAgICAgICAgICAgICdwYWludCc6IHsKICAgICAgICAgICAgICAgICdmaWxsLWV4dHJ1c2lvbi1jb2xvcic6ICcjYWFhJywKCiAgICAgICAgICAgICAgICAvLyBVc2UgYW4gJ2ludGVycG9sYXRlJyBleHByZXNzaW9uIHRvCiAgICAgICAgICAgICAgICAvLyBhZGQgYSBzbW9vdGggdHJhbnNpdGlvbiBlZmZlY3QgdG8KICAgICAgICAgICAgICAgIC8vIHRoZSBidWlsZGluZ3MgYXMgdGhlIHVzZXIgem9vbXMgaW4uCiAgICAgICAgICAgICAgICAnZmlsbC1leHRydXNpb24taGVpZ2h0JzogWwogICAgICAgICAgICAgICAgICAnaW50ZXJwb2xhdGUnLAogICAgICAgICAgICAgICAgICBbJ2xpbmVhciddLAogICAgICAgICAgICAgICAgICBbJ3pvb20nXSwKICAgICAgICAgICAgICAgICAgOSwKICAgICAgICAgICAgICAgICAgMCwKICAgICAgICAgICAgICAgICAgMTUuMDUsCiAgICAgICAgICAgICAgICAgIFsnZ2V0JywgJ2hlaWdodCddCiAgICAgICAgICAgICAgICBdLAogICAgICAgICAgICAgICAgJ2ZpbGwtZXh0cnVzaW9uLWJhc2UnOiBbCiAgICAgICAgICAgICAgICAgICdpbnRlcnBvbGF0ZScsCiAgICAgICAgICAgICAgICAgIFsnbGluZWFyJ10sCiAgICAgICAgICAgICAgICAgIFsnem9vbSddLAogICAgICAgICAgICAgICAgICA5LAogICAgICAgICAgICAgICAgICAwLAogICAgICAgICAgICAgICAgICAxNS4wNSwKICAgICAgICAgICAgICAgICAgWydnZXQnLCAnbWluX2hlaWdodCddCiAgICAgICAgICAgICAgICBdLAoKICAgICAgICAgICAgICAgIC8vICdmaWxsLWV4dHJ1c2lvbi1oZWlnaHQnOiBbJ2dldCcsICdoZWlnaHQnXSwKICAgICAgICAgICAgICAgICdmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5JzogMC44LAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0pOwoKICAgICAgICAgIH0pOwoKICAgICAgICAgIC8vIC8vIEFkZCBzcGhlcmVzIHRvIG1hcAogICAgICAgICAgLy8gY29uc3QgX3RoaXMgPSB0aGlzCiAgICAgICAgICAvLyB0aGlzLm1hcC5hZGRMYXllcih7CiAgICAgICAgICAvLyAgIGlkOiAiY3VzdG9tX2xheWVyIiwKICAgICAgICAgIC8vICAgdHlwZTogImN1c3RvbSIsCiAgICAgICAgICAvLyAgIHJlbmRlcmluZ01vZGU6ICIzZCIsCiAgICAgICAgICAvLwogICAgICAgICAgLy8gICBvbkFkZDogZnVuY3Rpb24gKG1hcCwgbWJ4Q29udGV4dCkgewogICAgICAgICAgLy8gICAgIHdpbmRvdy50Yi5hZGQoX3RoaXMuc3BoZXJlKC0xMjMuMTA2ODY1OCwgNDkuMjYyNjk4MikpOwogICAgICAgICAgLy8gICAgIHdpbmRvdy50Yi5hZGQoX3RoaXMuc3BoZXJlKC0xMjMuMTA4ODY1OCwgNDkuMjYyNjk4MikpOwogICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKG1hcCkKICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhtYnhDb250ZXh0KQogICAgICAgICAgLy8gICAgIGxldCBwdWxzZU9iaiA9IHdpbmRvdy50YgogICAgICAgICAgLy8gICAgICAgLk9iamVjdDNEKHsgb2JqOiBwdWxzZSwgdW5pdHM6ICJtZXRlcnMiIH0pCiAgICAgICAgICAvLyAgICAgICAuc2V0Q29vcmRzKFstMTIzLjEwNjg2NTgsIDQ5LjI2MjY5ODIsIDBdKTsKICAgICAgICAgIC8vCiAgICAgICAgICAvLyAgICAgcHVsc2VPYmouc2V0QW5jaG9yKCJib3R0b20tbGVmdCIpOwogICAgICAgICAgLy8KICAgICAgICAgIC8vICAgICB3aW5kb3cudGIuYWRkKHB1bHNlT2JqKTsKICAgICAgICAgIC8vICAgfSwKICAgICAgICAgIC8vICAgcmVuZGVyOiBmdW5jdGlvbiAoZ2wsIG1hdHJpeCkgewogICAgICAgICAgLy8gICAgIHdpbmRvdy50Yi51cGRhdGUoKTsKICAgICAgICAgIC8vICAgICBfdGhpcy5hbmltYXRlUHVsc2UoKTsKICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhnbCkKICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhtYXRyaXgpCiAgICAgICAgICAvLyAgIH0sCiAgICAgICAgICAvLyB9KTsKCiAgICAgICAgfQogICAgICB9KTsKCiAgICAgIC8vIEFkZCBkcmF3IGNvbnRyb2xzCiAgICAgIGNvbnN0IGRyYXcgPSBuZXcgTWFwYm94RHJhdygpOwogICAgICB0aGlzLm1hcC5hZGRDb250cm9sKGRyYXcsICd0b3AtcmlnaHQnKTsKCiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYXJlYSBvZiBkcmF3biBwb2x5Z29ucwogICAgICBmdW5jdGlvbiB1cGRhdGVBcmVhKCkgewogICAgICAgICAgY29uc3QgZGF0YSA9IGRyYXcuZ2V0QWxsKCk7CiAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FsY3VsYXRlZC1hcmVhJyk7CiAgICAgICAgICBpZiAoZGF0YS5mZWF0dXJlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSB0dXJmLmFyZWEoZGF0YSk7CgogICAgICAgICAgICAvLyBSZXN0cmljdCB0aGUgYXJlYSB0byAyIGRlY2ltYWwgcG9pbnRzLgogICAgICAgICAgICBjb25zdCByb3VuZGVkX2FyZWEgPSBNYXRoLnJvdW5kKGFyZWEgKiAxMDApIC8gMTAwOwogICAgICAgICAgICBhbnN3ZXIuaW5uZXJIVE1MID0gYDxwPjxzdHJvbmc+JHtyb3VuZGVkX2FyZWF9PC9zdHJvbmc+IG3CsjwvcD5gOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYW5zd2VyLmlubmVySFRNTCA9ICcnOwogICAgICAgICAgICAvLyBpZiAoZS50eXBlICE9PSAnZHJhdy5kZWxldGUnKQogICAgICAgICAgICAvLyAgIGFsZXJ0KCdDbGljayB0aGUgbWFwIHRvIGRyYXcgYSBwb2x5Z29uLicpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy5tYXAub24oJ2RyYXcuY3JlYXRlJywgdXBkYXRlQXJlYSk7CiAgICAgIHRoaXMubWFwLm9uKCdkcmF3LmRlbGV0ZScsIHVwZGF0ZUFyZWEpOwogICAgICB0aGlzLm1hcC5vbignZHJhdy51cGRhdGUnLCB1cGRhdGVBcmVhKTsKCiAgICAgIHRoaXMubWFwLm9uKCdkcmF3LmNyZWF0ZScsICgpID0+IHsKICAgICAgICB0aGlzLm1hcC5hZGRTb3VyY2UoJ2RyYXcnLCB7CiAgICAgICAgICAndHlwZSc6ICdnZW9qc29uJywKICAgICAgICAgICdkYXRhJzogZ2VuZXJhdGVCbG9ja3MoZHJhdywgOCksCiAgICAgICAgfSk7CiAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIoewogICAgICAgICAgJ2lkJzogJ291dGxpbmUnLAogICAgICAgICAgJ3R5cGUnOiAnZmlsbCcsCiAgICAgICAgICAnc291cmNlJzogJ2RyYXcnLAogICAgICAgICAgJ3BhaW50JzogewogICAgICAgICAgICAnZmlsbC1jb2xvcic6ICcjMDZiZTdmJywKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfSk7CgogICAgICB0aGlzLm1hcC5vbignZHJhdy5kZWxldGUnLCAoKSA9PiB7CiAgICAgICAgZGVsZXRlT3V0bGluZURyYXdzKHRoaXMubWFwKQogICAgICB9KTsKCiAgICAgIHRoaXMubWFwLm9uKCdkcmF3LnVwZGF0ZScsICgpID0+IHsKICAgICAgICBkZWxldGVPdXRsaW5lRHJhd3ModGhpcy5tYXApCiAgICAgICAgdGhpcy5tYXAuYWRkU291cmNlKCdkcmF3JywgewogICAgICAgICAgJ3R5cGUnOiAnZ2VvanNvbicsCiAgICAgICAgICAnZGF0YSc6IGdlbmVyYXRlQmxvY2tzKGRyYXcsIDgpLAogICAgICAgIH0pOwogICAgICAgIHRoaXMubWFwLmFkZExheWVyKHsKICAgICAgICAgICdpZCc6ICdvdXRsaW5lJywKICAgICAgICAgICd0eXBlJzogJ2ZpbGwnLAogICAgICAgICAgJ3NvdXJjZSc6ICdkcmF3JywKICAgICAgICAgICdwYWludCc6IHsKICAgICAgICAgICAgJ2ZpbGwtY29sb3InOiAnIzA2YmU3ZicgLy8gcmVkIGNvbG9yCiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0pOwoKICAgICAgaWYgKHRoaXMubWFya2Vycy5sZW5ndGggPiAwKSB7CiAgICAgICAgdGhpcy5yZXNldE1hcmtlcnMoKTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuY3VycmVudEZlYXR1cmVzKSB7CiAgICAgICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7CiAgICAgIH0KICAgIH0sCiAgICByZXNldE1hcmtlcnMoKSB7CiAgICAgIHRoaXMubWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHsKICAgICAgICBtYXJrZXIucmVtb3ZlKCk7CiAgICAgIH0pOwogICAgICB0aGlzLm1hcmtlcnMgPSBbXTsKICAgIH0sCiAgICB1cGRhdGVNYXJrZXJzKCkgewogICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmN1cnJlbnRGZWF0dXJlcy5mZWF0dXJlcy5tYXAoKGZlYXR1cmUpID0+IHsKICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpOwogICAgICAgIGVsLmNsYXNzTmFtZSA9ICJtYXJrZXIiOwoKICAgICAgICAvLyBjcmVhdGUgdGhlIHBvcHVwCiAgICAgICAgY29uc3QgcG9wdXAgPSB0aGlzLmZlYXR1cmVQb3B1cChmZWF0dXJlKTsKICAgICAgICByZXR1cm4gbmV3IG1hcGJveGdsLk1hcmtlcihlbCkuc2V0TG5nTGF0KGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpLnNldFBvcHVwKHBvcHVwKS5hZGRUbyh0aGlzLm1hcCk7CiAgICAgIH0pOwogICAgfSwKICB9LAp9OwoK"},{"version":3,"sources":["ThreeboxExample.vue"],"names":[],"mappings":";;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ThreeboxExample.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div>\n    <div id=\"map\"></div>\n    <div id=\"vue-range-slider\">\n      <RangeSlider v-on:changeValue=\"updateValue($event)\"/>\n    </div>\n  </div>\n</template>\n\n<script>\nimport mapboxgl from \"mapbox-gl\";\nimport * as MapboxDraw from 'mapbox-gl-draw';\nimport threebox from \"threebox-plugin/dist/threebox\";\nimport { Threebox } from 'threebox-plugin';\nimport Pulse from \"./Pulses/Pulse\";\nimport * as turf from '@turf/turf';\nimport RangeSlider from \"./RangeSlider\"\nimport { mapState } from \"vuex\";\n\n\nconsole.log(mapState)\nlet pulse = new Pulse(400, 4000, true);\nthreebox\n\n\n// Returns true if finds a defined key in the input array of dictionaries\nfunction keyInDictionary (dictionaries, keyToFind) {\n    for (var i in dictionaries) {\n        if (dictionaries[i]['id'] == keyToFind) {\n            return true\n        }\n    }\n}\n\n\n// Returns a list of centroids of multiple LineStrings\nfunction lineCentroids(lines) {\n  const centroids = [];\n  for (let i = 0; i < lines.features.length; i++) {\n    const line = turf.lineString(lines.features[i])\n    const ctr = turf.centroid(line['geometry']['coordinates'])\n    centroids.push(ctr)\n  }\n  return centroids\n}\n\n\n// Returns points along a LineString divided according to a specified length in meters\nfunction divideLineString(line, length=100) {\n  const chunks = turf.lineChunk(line, length, {units: 'meters'})\n  return lineCentroids(chunks)\n}\n\n\n// Extract drawn shape and convert it to a polygon\nfunction getPolygonDrawn(draw){\n  const data = draw.getAll()\n  return turf.polygon(data.features[0]['geometry']['coordinates'])\n}\n\n\n// Extract internal skeleton of a shape\nfunction voronoiSkeleton(draw){\n  const pol = getPolygonDrawn(draw)\n  const line = turf.polygonToLine(pol)\n  const chunks = turf.lineChunk(line, 0.01)\n  const centroids = lineCentroids(chunks)\n  const centroids_gj = {\n    \"type\": \"FeatureCollection\",\n    \"features\": centroids\n  }\n  const voronoi = turf.voronoi(centroids_gj)\n  // Iterate over voronoi polygons to extract segments inside drawing\n  const voronoiLines = [];\n  for (let i = 0; i < voronoi.features.length; i++) {\n    const voronoiPolygon = turf.polygon(voronoi.features[i]['geometry']['coordinates']);\n    const voronoiLine = turf.polygonToLine(voronoiPolygon)\n    const voronoiSegments = turf.lineSegment(voronoiLine)\n    for (let i = 0; i < voronoiSegments.features.length; i++) {\n      const segmentCentroid = turf.centroid(voronoiSegments.features[i])\n      if (turf.booleanContains(pol, segmentCentroid)) {\n        voronoiLines.push(voronoiSegments.features[i])\n      }\n    }\n  }\n  const voronoiLinesGeoJSON = {\n    \"type\": \"FeatureCollection\",\n    \"features\": voronoiLines\n  }\n  const voronoiLinesCombined = turf.combine(voronoiLinesGeoJSON)\n  const voronoiLinesSimplified = turf.simplify(voronoiLinesCombined,\n    {tolerance: 5, mutate: true})\n  return voronoiLinesSimplified\n}\n\n\n// Generate skeleton and buffer according to some number of iterations\nfunction bufferDrawSkeleton(skeleton) {\n  const bufferedSkeletons = []\n  for (let i = 0; i < 3; i++) {\n    const skeletonBuffer = turf.buffer(skeleton, 30 * (i+1), {units: 'meters'})\n    const dissolvedSkeleton = turf.dissolve(skeletonBuffer)\n    bufferedSkeletons.push(turf.lineString(dissolvedSkeleton.features[0]['geometry']['coordinates'][0]))\n  }\n  return bufferedSkeletons\n}\n\n\n// Subdivide a drawn shape using Voronoi patterns\nfunction subdivideShape(draw) {\n  const skeleton = voronoiSkeleton(draw)\n  const skeletonBufferSmall = turf.buffer(skeleton, 0.1, {units: 'meters'}).features[0]\n  const skeletonLine = turf.polygonToLine(skeletonBufferSmall)\n  const dividedSkeleton = divideLineString(turf.combine(skeletonLine))\n  const voronoiSkeletonBuffers = bufferDrawSkeleton(skeleton)\n  const perpendicularLines = []\n  for (let i = 0; i < dividedSkeleton.length; i++) {\n    var originalPoint = dividedSkeleton[i]\n    const nearestPoints = [originalPoint['geometry']['coordinates']]\n    for (let j = 0; j < voronoiSkeletonBuffers.length; j++) {\n      const buffer = voronoiSkeletonBuffers[j]\n      const nextPoint = turf.nearestPointOnLine(buffer, turf.point(originalPoint['geometry']['coordinates']))\n      nearestPoints.push(nextPoint['geometry']['coordinates'])\n      originalPoint = nextPoint\n    }\n    perpendicularLines.push(turf.lineString(nearestPoints))\n  }\n  // Buffer lines and subtract\n  const centerlines = turf.featureCollection(perpendicularLines.concat(skeleton.features, voronoiSkeletonBuffers))\n  return centerlines\n}\n\n\nfunction generateBlocks(draw, street_width) {\n  const bufferedCenterlines = turf.dissolve(turf.buffer(subdivideShape(draw), street_width/2, {units: 'meters'}))\n  return turf.difference(getPolygonDrawn(draw), bufferedCenterlines.features[0])\n}\n\n\nfunction deleteOutlineDraws(map) {\n  if (keyInDictionary(map.getStyle().layers, 'outline')) {\n    map.removeLayer('outline')\n  }\n  if ('draw' in map.getStyle().sources) {\n    map.removeSource('draw')\n  }\n}\n\n\nexport default {\n  name: \"ThreeboxExample\",\n  data() {\n    return {\n      accessToken:\n        \"pk.eyJ1IjoibmljaG9sYXNtYXJ0aW5vIiwiYSI6ImNrMjVhOGphOTAzZGUzbG8wNHJhdTZrMmYifQ.98uDMnGIvn1zrw4ZWUO35g\",\n      value: null,\n      drawing: null,\n      markers: []\n    };\n  },\n  mounted() {\n    this.initMap()\n  },\n  components: {\n    RangeSlider\n  },\n  computed: {\n  ...mapState([\"currentFeatures\"]),\n  },\n  watch: {\n    currentFeatures: {\n      handler() {\n        if (this.currentFeatures) {\n          this.resetMarkers();\n          this.updateMarkers();\n          console.log(this.currentFeatures)\n\n        }\n      },\n      deep: true,\n    },\n  },\n  methods: {\n    updateValue(value) {\n      this.value = value\n      console.log(\"Value updated to\", this.value)\n    },\n    sphere(lon, lat) {\n      let origin = [lon, lat, 0];\n      return window.tb\n        .sphere({ color: \"red\", material: \"MeshToonMaterial\" })\n        .setCoords(origin);\n    },\n    animatePulse() {\n      pulse.update();\n      this.map.triggerRepaint();\n    },\n    initMap() {\n      mapboxgl.accessToken = this.accessToken;\n      this.map = new mapboxgl.Map({\n        container: \"map\",\n        interactive: true,\n        style:  \"mapbox://styles/mapbox/dark-v10\",\n        zoom: 16,\n        center: [-123.1068658, 49.2626982],\n        pitch: 60,\n        bearing: 360,\n        antialias: true,\n        // attributionControl: false\n      }).on(\"style.load\", () => {\n        window.tb = new Threebox(\n          this.map,\n          this.map.getCanvas().getContext(\"webgl\"),\n          {\n            defaultLights: true,\n          }\n        );\n\n        // Add draw control\n        if (this.map.getLayer(\"custom_layer\") == null) {\n\n          this.map.on('load', () => {\n\n            // // Add 3D terrain\n            // this.map.addSource('mapbox-dem', {\n            //   'type': 'raster-dem',\n            //   'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',\n            //   'tileSize': 512,\n            //   'maxzoom': 20\n            // });\n            //\n            // // add the DEM source as a terrain layer with exaggerated height\n            // this.map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });\n\n            // // Add parcels layer source (CoV)\n            // this.map.addSource('property-parcel-polygons', {\n            //   'type': 'geojson',\n            //   'data': 'https://raw.githubusercontent.com/nicholasmartino/vue-threebox/master/public/data/property-parcel-polygons.geojson',\n            // });\n            //\n            // // Add parcels layer to map\n            // this.map.addLayer({\n            //   'id': 'property-parcel-polygons-shp',\n            //   'type': 'fill',\n            //   'source': 'property-parcel-polygons',\n            //   'paint': {\n            //     'fill-color': '#0080ff', // blue color fill\n            //     'fill-opacity': 0.2,\n            //   },\n            // });\n\n            // The 'building' layer in the Mapbox Streets\n            // vector tileset contains building height data\n            // from OpenStreetMap.\n            this.map.addLayer({\n              'id': 'add-3d-buildings',\n              'source': 'composite',\n              'source-layer': 'building',\n              'filter': ['==', 'extrude', 'true'],\n              'type': 'fill-extrusion',\n              'minzoom': 12,\n              'paint': {\n                'fill-extrusion-color': '#aaa',\n\n                // Use an 'interpolate' expression to\n                // add a smooth transition effect to\n                // the buildings as the user zooms in.\n                'fill-extrusion-height': [\n                  'interpolate',\n                  ['linear'],\n                  ['zoom'],\n                  9,\n                  0,\n                  15.05,\n                  ['get', 'height']\n                ],\n                'fill-extrusion-base': [\n                  'interpolate',\n                  ['linear'],\n                  ['zoom'],\n                  9,\n                  0,\n                  15.05,\n                  ['get', 'min_height']\n                ],\n\n                // 'fill-extrusion-height': ['get', 'height'],\n                'fill-extrusion-opacity': 0.8,\n              },\n            });\n\n          });\n\n          // // Add spheres to map\n          // const _this = this\n          // this.map.addLayer({\n          //   id: \"custom_layer\",\n          //   type: \"custom\",\n          //   renderingMode: \"3d\",\n          //\n          //   onAdd: function (map, mbxContext) {\n          //     window.tb.add(_this.sphere(-123.1068658, 49.2626982));\n          //     window.tb.add(_this.sphere(-123.1088658, 49.2626982));\n          //     console.log(map)\n          //     console.log(mbxContext)\n          //     let pulseObj = window.tb\n          //       .Object3D({ obj: pulse, units: \"meters\" })\n          //       .setCoords([-123.1068658, 49.2626982, 0]);\n          //\n          //     pulseObj.setAnchor(\"bottom-left\");\n          //\n          //     window.tb.add(pulseObj);\n          //   },\n          //   render: function (gl, matrix) {\n          //     window.tb.update();\n          //     _this.animatePulse();\n          //     console.log(gl)\n          //     console.log(matrix)\n          //   },\n          // });\n\n        }\n      });\n\n      // Add draw controls\n      const draw = new MapboxDraw();\n      this.map.addControl(draw, 'top-right');\n\n      // Calculate the area of drawn polygons\n      function updateArea() {\n          const data = draw.getAll();\n          const answer = document.getElementById('calculated-area');\n          if (data.features.length > 0) {\n            const area = turf.area(data);\n\n            // Restrict the area to 2 decimal points.\n            const rounded_area = Math.round(area * 100) / 100;\n            answer.innerHTML = `<p><strong>${rounded_area}</strong> m²</p>`;\n          } else {\n            answer.innerHTML = '';\n            // if (e.type !== 'draw.delete')\n            //   alert('Click the map to draw a polygon.');\n        }\n      }\n\n      this.map.on('draw.create', updateArea);\n      this.map.on('draw.delete', updateArea);\n      this.map.on('draw.update', updateArea);\n\n      this.map.on('draw.create', () => {\n        this.map.addSource('draw', {\n          'type': 'geojson',\n          'data': generateBlocks(draw, 8),\n        });\n        this.map.addLayer({\n          'id': 'outline',\n          'type': 'fill',\n          'source': 'draw',\n          'paint': {\n            'fill-color': '#06be7f',\n          }\n        });\n      });\n\n      this.map.on('draw.delete', () => {\n        deleteOutlineDraws(this.map)\n      });\n\n      this.map.on('draw.update', () => {\n        deleteOutlineDraws(this.map)\n        this.map.addSource('draw', {\n          'type': 'geojson',\n          'data': generateBlocks(draw, 8),\n        });\n        this.map.addLayer({\n          'id': 'outline',\n          'type': 'fill',\n          'source': 'draw',\n          'paint': {\n            'fill-color': '#06be7f' // red color\n          }\n        });\n      });\n\n      if (this.markers.length > 0) {\n        this.resetMarkers();\n      }\n\n      if (this.currentFeatures) {\n        this.updateMarkers();\n      }\n    },\n    resetMarkers() {\n      this.markers.forEach((marker) => {\n        marker.remove();\n      });\n      this.markers = [];\n    },\n    updateMarkers() {\n      this.markers = this.currentFeatures.features.map((feature) => {\n        const el = document.createElement(\"div\");\n        el.className = \"marker\";\n\n        // create the popup\n        const popup = this.featurePopup(feature);\n        return new mapboxgl.Marker(el).setLngLat(feature.geometry.coordinates).setPopup(popup).addTo(this.map);\n      });\n    },\n  },\n};\n\n</script>\n\n\n<style>\n#map {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n}\n@import \"https://api.mapbox.com/mapbox-gl-js/v0.42.0/mapbox-gl.css\";\n@import \"https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.2/mapbox-gl-draw.css\";\n.mapboxgl-ctrl-group button {\n    width: 29px;\n    height: 29px;\n    display: block;\n    padding: 0;\n    outline: none;\n    border: 0;\n    box-sizing: border-box;\n    background-color: transparent;\n    cursor: pointer;\n    overflow: hidden;\n}\n.mapboxgl-ctrl-top-right {\n    top: 0;\n    right: 0;\n    position: absolute;\n}\n</style>\n"]}]}