{"remainingRequest":"/Users/nicholasmartino/JavaScript/site-divider/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/nicholasmartino/JavaScript/site-divider/src/components/Map.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/nicholasmartino/JavaScript/site-divider/src/components/Map.vue","mtime":1642611179488},{"path":"/Users/nicholasmartino/JavaScript/site-divider/node_modules/cache-loader/dist/cjs.js","mtime":1639173070060},{"path":"/Users/nicholasmartino/JavaScript/site-divider/node_modules/babel-loader/lib/index.js","mtime":1639173071039},{"path":"/Users/nicholasmartino/JavaScript/site-divider/node_modules/cache-loader/dist/cjs.js","mtime":1639173070060},{"path":"/Users/nicholasmartino/JavaScript/site-divider/node_modules/vue-loader/lib/index.js","mtime":1639173071313}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBtYXBib3hnbCBmcm9tICJtYXBib3gtZ2wiOwppbXBvcnQgKiBhcyBNYXBib3hEcmF3IGZyb20gJ21hcGJveC1nbC1kcmF3JzsKaW1wb3J0IHRocmVlYm94IGZyb20gInRocmVlYm94LXBsdWdpbi9kaXN0L3RocmVlYm94IjsKaW1wb3J0IHsgVGhyZWVib3ggfSBmcm9tICd0aHJlZWJveC1wbHVnaW4nOwppbXBvcnQgUHVsc2UgZnJvbSAiLi9QdWxzZXMvUHVsc2UiOwppbXBvcnQgKiBhcyB0dXJmIGZyb20gJ0B0dXJmL3R1cmYnOwovLyBpbXBvcnQgUmFuZ2VTbGlkZXIgZnJvbSAiLi9SYW5nZVNsaWRlciIKCgpsZXQgcHVsc2UgPSBuZXcgUHVsc2UoNDAwLCA0MDAwLCB0cnVlKTsKdGhyZWVib3gKCgovLyBDYWxjdWxhdGUgdGhlIGFyZWEgb2YgZHJhd24gcG9seWdvbnMKZnVuY3Rpb24gdXBkYXRlQXJlYShkcmF3KSB7CiAgICBjb25zdCBkYXRhID0gZHJhdy5nZXRBbGwoKTsKICAgIGNvbnN0IGFyZWFfZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbGN1bGF0ZWQtYXJlYScpCgogICAgaWYgKGRhdGEuZmVhdHVyZXMubGVuZ3RoID4gMCkgewogICAgICBjb25zdCBhcmVhID0gTWF0aC5yb3VuZCh0dXJmLmFyZWEoZGF0YSkgKiAxMDApIC8gMTAwCiAgICAgIC8vIFJlc3RyaWN0IHRoZSBhcmVhIHRvIDIgZGVjaW1hbCBwb2ludHMuCiAgICAgIGFyZWFfZGl2LmlubmVySFRNTCA9IGA8cD48c3Ryb25nPiR7YXJlYX08L3N0cm9uZz4gbcKyPC9wPmAKICAgIH0gZWxzZSB7CiAgICAgIGFyZWFfZGl2LmlubmVySFRNTCA9IGAtYAoKICAgICAgLy8gaWYgKGUudHlwZSAhPT0gJ2RyYXcuZGVsZXRlJykKICAgICAgLy8gICBhbGVydCgnQ2xpY2sgdGhlIG1hcCB0byBkcmF3IGEgcG9seWdvbi4nKTsKICB9Cn0KCi8vIFJldHVybnMgdHJ1ZSBpZiBmaW5kcyBhIGRlZmluZWQga2V5IGluIHRoZSBpbnB1dCBhcnJheSBvZiBkaWN0aW9uYXJpZXMKZnVuY3Rpb24ga2V5SW5EaWN0aW9uYXJ5IChkaWN0aW9uYXJpZXMsIGtleVRvRmluZCkgewogICAgZm9yICh2YXIgaSBpbiBkaWN0aW9uYXJpZXMpIHsKICAgICAgICBpZiAoZGljdGlvbmFyaWVzW2ldWydpZCddID09IGtleVRvRmluZCkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZQogICAgICAgIH0KICAgIH0KfQoKCi8vIFJldHVybnMgYSBsaXN0IG9mIGNlbnRyb2lkcyBvZiBtdWx0aXBsZSBMaW5lU3RyaW5ncwpmdW5jdGlvbiBsaW5lQ2VudHJvaWRzKGxpbmVzKSB7CiAgY29uc3QgY2VudHJvaWRzID0gW107CiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5mZWF0dXJlcy5sZW5ndGg7IGkrKykgewogICAgY29uc3QgbGluZSA9IHR1cmYubGluZVN0cmluZyhsaW5lcy5mZWF0dXJlc1tpXSkKICAgIGNvbnN0IGN0ciA9IHR1cmYuY2VudHJvaWQobGluZVsnZ2VvbWV0cnknXVsnY29vcmRpbmF0ZXMnXSkKICAgIGNlbnRyb2lkcy5wdXNoKGN0cikKICB9CiAgcmV0dXJuIGNlbnRyb2lkcwp9CgoKLy8gUmV0dXJucyBwb2ludHMgYWxvbmcgYSBMaW5lU3RyaW5nIGRpdmlkZWQgYWNjb3JkaW5nIHRvIGEgc3BlY2lmaWVkIGxlbmd0aCBpbiBtZXRlcnMKZnVuY3Rpb24gZGl2aWRlTGluZVN0cmluZyhsaW5lLCBsZW5ndGg9MTAwKSB7CiAgY29uc3QgY2h1bmtzID0gdHVyZi5saW5lQ2h1bmsobGluZSwgbGVuZ3RoLCB7dW5pdHM6ICdtZXRlcnMnfSkKICByZXR1cm4gbGluZUNlbnRyb2lkcyhjaHVua3MpCn0KCgovLyBFeHRyYWN0IGRyYXduIHNoYXBlIGFuZCBjb252ZXJ0IGl0IHRvIGEgcG9seWdvbgpmdW5jdGlvbiBnZXRQb2x5Z29uRHJhd24oZHJhdyl7CiAgY29uc3QgZGF0YSA9IGRyYXcuZ2V0QWxsKCkKICByZXR1cm4gdHVyZi5wb2x5Z29uKGRhdGEuZmVhdHVyZXNbMF1bJ2dlb21ldHJ5J11bJ2Nvb3JkaW5hdGVzJ10pCn0KCgovLyBFeHRyYWN0IGludGVybmFsIHNrZWxldG9uIG9mIGEgc2hhcGUKZnVuY3Rpb24gdm9yb25vaVNrZWxldG9uKGRyYXcpewogIGNvbnN0IHBvbCA9IGdldFBvbHlnb25EcmF3bihkcmF3KQogIGNvbnN0IGxpbmUgPSB0dXJmLnBvbHlnb25Ub0xpbmUocG9sKQogIGNvbnN0IGNodW5rcyA9IHR1cmYubGluZUNodW5rKGxpbmUsIDAuMDEpCiAgY29uc3QgY2VudHJvaWRzID0gbGluZUNlbnRyb2lkcyhjaHVua3MpCiAgY29uc3QgY2VudHJvaWRzX2dqID0gewogICAgInR5cGUiOiAiRmVhdHVyZUNvbGxlY3Rpb24iLAogICAgImZlYXR1cmVzIjogY2VudHJvaWRzCiAgfQogIGNvbnN0IHZvcm9ub2kgPSB0dXJmLnZvcm9ub2koY2VudHJvaWRzX2dqKQogIC8vIEl0ZXJhdGUgb3ZlciB2b3Jvbm9pIHBvbHlnb25zIHRvIGV4dHJhY3Qgc2VnbWVudHMgaW5zaWRlIGRyYXdpbmcKICBjb25zdCB2b3Jvbm9pTGluZXMgPSBbXTsKICBmb3IgKGxldCBpID0gMDsgaSA8IHZvcm9ub2kuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHsKICAgIGNvbnN0IHZvcm9ub2lQb2x5Z29uID0gdHVyZi5wb2x5Z29uKHZvcm9ub2kuZmVhdHVyZXNbaV1bJ2dlb21ldHJ5J11bJ2Nvb3JkaW5hdGVzJ10pOwogICAgY29uc3Qgdm9yb25vaUxpbmUgPSB0dXJmLnBvbHlnb25Ub0xpbmUodm9yb25vaVBvbHlnb24pCiAgICBjb25zdCB2b3Jvbm9pU2VnbWVudHMgPSB0dXJmLmxpbmVTZWdtZW50KHZvcm9ub2lMaW5lKQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2b3Jvbm9pU2VnbWVudHMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3Qgc2VnbWVudENlbnRyb2lkID0gdHVyZi5jZW50cm9pZCh2b3Jvbm9pU2VnbWVudHMuZmVhdHVyZXNbaV0pCiAgICAgIGlmICh0dXJmLmJvb2xlYW5Db250YWlucyhwb2wsIHNlZ21lbnRDZW50cm9pZCkpIHsKICAgICAgICB2b3Jvbm9pTGluZXMucHVzaCh2b3Jvbm9pU2VnbWVudHMuZmVhdHVyZXNbaV0pCiAgICAgIH0KICAgIH0KICB9CiAgY29uc3Qgdm9yb25vaUxpbmVzR2VvSlNPTiA9IHsKICAgICJ0eXBlIjogIkZlYXR1cmVDb2xsZWN0aW9uIiwKICAgICJmZWF0dXJlcyI6IHZvcm9ub2lMaW5lcwogIH0KICBjb25zdCB2b3Jvbm9pTGluZXNDb21iaW5lZCA9IHR1cmYuY29tYmluZSh2b3Jvbm9pTGluZXNHZW9KU09OKQogIGNvbnN0IHZvcm9ub2lMaW5lc1NpbXBsaWZpZWQgPSB0dXJmLnNpbXBsaWZ5KHZvcm9ub2lMaW5lc0NvbWJpbmVkLAogICAge3RvbGVyYW5jZTogNSwgbXV0YXRlOiB0cnVlfSkKICByZXR1cm4gdm9yb25vaUxpbmVzU2ltcGxpZmllZAp9CgoKLy8gR2VuZXJhdGUgc2tlbGV0b24gYW5kIGJ1ZmZlciBhY2NvcmRpbmcgdG8gc29tZSBudW1iZXIgb2YgaXRlcmF0aW9ucwpmdW5jdGlvbiBidWZmZXJEcmF3U2tlbGV0b24oc2tlbGV0b24pIHsKICBjb25zdCBidWZmZXJlZFNrZWxldG9ucyA9IFtdCiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHsKICAgIGNvbnN0IHNrZWxldG9uQnVmZmVyID0gdHVyZi5idWZmZXIoc2tlbGV0b24sIDMwICogKGkrMSksIHt1bml0czogJ21ldGVycyd9KQogICAgY29uc3QgZGlzc29sdmVkU2tlbGV0b24gPSB0dXJmLmRpc3NvbHZlKHNrZWxldG9uQnVmZmVyKQogICAgYnVmZmVyZWRTa2VsZXRvbnMucHVzaCh0dXJmLmxpbmVTdHJpbmcoZGlzc29sdmVkU2tlbGV0b24uZmVhdHVyZXNbMF1bJ2dlb21ldHJ5J11bJ2Nvb3JkaW5hdGVzJ11bMF0pKQogIH0KICByZXR1cm4gYnVmZmVyZWRTa2VsZXRvbnMKfQoKCi8vIFN1YmRpdmlkZSBhIGRyYXduIHNoYXBlIHVzaW5nIFZvcm9ub2kgcGF0dGVybnMKZnVuY3Rpb24gc3ViZGl2aWRlU2hhcGUoZHJhdykgewogIGNvbnN0IG91dHB1dCA9IHt9CiAgY29uc3Qgc2tlbGV0b24gPSB2b3Jvbm9pU2tlbGV0b24oZHJhdykKICBvdXRwdXQuc2tlbGV0b24gPSBza2VsZXRvbi5mZWF0dXJlcwogIGNvbnN0IHNrZWxldG9uQnVmZmVyU21hbGwgPSB0dXJmLmJ1ZmZlcihza2VsZXRvbiwgMC4xLCB7dW5pdHM6ICdtZXRlcnMnfSkuZmVhdHVyZXNbMF0KICBjb25zdCBza2VsZXRvbkxpbmUgPSB0dXJmLnBvbHlnb25Ub0xpbmUoc2tlbGV0b25CdWZmZXJTbWFsbCkKICBjb25zdCBkaXZpZGVkU2tlbGV0b24gPSBkaXZpZGVMaW5lU3RyaW5nKHR1cmYuY29tYmluZShza2VsZXRvbkxpbmUpKQogIGNvbnN0IHZvcm9ub2lTa2VsZXRvbkJ1ZmZlcnMgPSBidWZmZXJEcmF3U2tlbGV0b24oc2tlbGV0b24pCiAgb3V0cHV0LnZvcm9ub2lTa2VsZXRvbkJ1ZmZlcnMgPSB2b3Jvbm9pU2tlbGV0b25CdWZmZXJzCiAgb3V0cHV0LnBlcnBlbmRpY3VsYXJMaW5lcyA9IFtdCiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXZpZGVkU2tlbGV0b24ubGVuZ3RoOyBpKyspIHsKICAgIHZhciBvcmlnaW5hbFBvaW50ID0gZGl2aWRlZFNrZWxldG9uW2ldCiAgICBjb25zdCBuZWFyZXN0UG9pbnRzID0gW29yaWdpbmFsUG9pbnRbJ2dlb21ldHJ5J11bJ2Nvb3JkaW5hdGVzJ11dCiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZvcm9ub2lTa2VsZXRvbkJ1ZmZlcnMubGVuZ3RoOyBqKyspIHsKICAgICAgY29uc3QgYnVmZmVyID0gdm9yb25vaVNrZWxldG9uQnVmZmVyc1tqXQogICAgICBjb25zdCBuZXh0UG9pbnQgPSB0dXJmLm5lYXJlc3RQb2ludE9uTGluZShidWZmZXIsIHR1cmYucG9pbnQob3JpZ2luYWxQb2ludFsnZ2VvbWV0cnknXVsnY29vcmRpbmF0ZXMnXSkpCiAgICAgIG5lYXJlc3RQb2ludHMucHVzaChuZXh0UG9pbnRbJ2dlb21ldHJ5J11bJ2Nvb3JkaW5hdGVzJ10pCiAgICAgIG9yaWdpbmFsUG9pbnQgPSBuZXh0UG9pbnQKICAgIH0KICAgIG91dHB1dC5wZXJwZW5kaWN1bGFyTGluZXMucHVzaCh0dXJmLmxpbmVTdHJpbmcobmVhcmVzdFBvaW50cykpCiAgfQogIHJldHVybiBvdXRwdXQKfQoKLy8gQnVmZmVyIGdlbmVyYXRlZCBsaW5lcyBhY2NvcmRpbmcgdG8gYnVmZmVyIHJhbmdlIGFuZCBzdWJ0cmFjdCBmcm9tIG9yaWdpbmFsIGRyYXdpbmcKZnVuY3Rpb24gZ2VuZXJhdGVCbG9ja3MoZHJhdywgYnVmZmVyUmFuZ2UpIHsKICBjb25zdCBidWZmZXJPcHRpb25zID0ge3VuaXRzOiAnbWV0ZXJzJ30KICBjb25zdCBzdWJkaXZpc2lvbnMgPSBzdWJkaXZpZGVTaGFwZShkcmF3KQogIGNvbnN0IHNrZWxldG9uQnVmZmVyID0gdHVyZi5idWZmZXIoc3ViZGl2aXNpb25zLnNrZWxldG9uWzBdLCBidWZmZXJSYW5nZVsxXS8yLCBidWZmZXJPcHRpb25zKQogIGNvbnN0IHBlcnBlbmRpY3VsYXJzQnVmZmVyZWQgPSB0dXJmLmJ1ZmZlcih0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKHN1YmRpdmlzaW9ucy5wZXJwZW5kaWN1bGFyTGluZXMpLCAoYnVmZmVyUmFuZ2VbMF0gKyBidWZmZXJSYW5nZVsxXSkvNCwgYnVmZmVyT3B0aW9ucykKICBjb25zdCBwYXJhbGxlbHNCdWZmZXJlZCA9IHR1cmYuYnVmZmVyKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oc3ViZGl2aXNpb25zLnZvcm9ub2lTa2VsZXRvbkJ1ZmZlcnMpLCBidWZmZXJSYW5nZVswXS8yLCBidWZmZXJPcHRpb25zKQogIGNvbnN0IGFsbEJ1ZmZlcnMgPSBwZXJwZW5kaWN1bGFyc0J1ZmZlcmVkLmZlYXR1cmVzLmNvbmNhdChwYXJhbGxlbHNCdWZmZXJlZC5mZWF0dXJlcywgc2tlbGV0b25CdWZmZXIpCiAgCiAgLy8gSXRlcmF0ZSBvdmVyIGJ1ZmZlcnMgdG8gZXh0cmFjdCBjb29yZHMKICBjb25zdCBhbGxCdWZmZXJzQ29vcmRzID0gW10KICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEJ1ZmZlcnMubGVuZ3RoOyBpKyspIHsKICAgIGNvbnNvbGUubG9nKGFsbEJ1ZmZlcnNbaV0pCiAgICBjb25zdCBidWZmZXIgPSBhbGxCdWZmZXJzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzCiAgICBhbGxCdWZmZXJzQ29vcmRzLnB1c2goYnVmZmVyKQogIH0KICAvLyBjb25zdCBidWZmZXJlZENlbnRlcmxpbmVzID0gdHVyZi5kaXNzb2x2ZShhbGxCdWZmZXJzKQogIC8vIGNvbnNvbGUubG9nKCJDZW50ZWxyaW5lcyBkaXNzb2x2ZWQiKQogIGNvbnNvbGUubG9nKHR1cmYubXVsdGlQb2x5Z29uKGFsbEJ1ZmZlcnNDb29yZHMpKQogIGNvbnN0IGRpZmZlcmVuY2UgPSB0dXJmLmRpZmZlcmVuY2UoZ2V0UG9seWdvbkRyYXduKGRyYXcpLCB0dXJmLm11bHRpUG9seWdvbihhbGxCdWZmZXJzQ29vcmRzKSkKICBjb25zb2xlLmxvZygiU3VidHJhY3Rpb24gcGVyZm9ybWVkIikKICBjb25zdCBzaW1wbGlmaWVkID0gdHVyZi5zaW1wbGlmeShkaWZmZXJlbmNlLCB7dG9sZXJhbmNlOiAwLjAwMDAxfSkKICBjb25zb2xlLmxvZygiU2ltcGxpZmljYXRpb24gY29tcGxldGVkIikKICByZXR1cm4gc2ltcGxpZmllZAp9CgoKZnVuY3Rpb24gZGVsZXRlT3V0bGluZURyYXdzKG1hcCkgewogIGlmIChrZXlJbkRpY3Rpb25hcnkobWFwLmdldFN0eWxlKCkubGF5ZXJzLCAnb3V0bGluZScpKSB7CiAgICBtYXAucmVtb3ZlTGF5ZXIoJ291dGxpbmUnKQogIH0KICBpZiAoJ2RyYXcnIGluIG1hcC5nZXRTdHlsZSgpLnNvdXJjZXMpIHsKICAgIG1hcC5yZW1vdmVTb3VyY2UoJ2RyYXcnKQogIH0KfQoKCmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEcmF3KG1hcGJveCwgZHJhdywgd2lkdGhSYW5nZSkgewogIGRlbGV0ZU91dGxpbmVEcmF3cyhtYXBib3gpCiAgbWFwYm94LmFkZFNvdXJjZSgnZHJhdycsIHsKICAgICd0eXBlJzogJ2dlb2pzb24nLAogICAgJ2RhdGEnOiBnZW5lcmF0ZUJsb2NrcyhkcmF3LCB3aWR0aFJhbmdlKSwKICB9KTsKICBtYXBib3guYWRkTGF5ZXIoewogICAgJ2lkJzogJ291dGxpbmUnLAogICAgJ3R5cGUnOiAnZmlsbCcsCiAgICAnc291cmNlJzogJ2RyYXcnLAogICAgJ3BhaW50JzogewogICAgICAnZmlsbC1jb2xvcic6ICcjMDZiZTdmJyAvLyByZWQgY29sb3IKICAgIH0KICB9KTsKfQoKCmZ1bmN0aW9uIGdldERhdGEobWFwYm94KSB7CiAgICBtYXBib3gub24oJ2NsaWNrJywgKGUpID0+IHsKICAgIC8vIFNldCBgYmJveGAgYXMgNXB4IHJlYWN0YW5nbGUgYXJlYSBhcm91bmQgY2xpY2tlZCBwb2ludC4KICAgIGNvbnN0IGJib3ggPSBbCiAgICAgIFtlLnBvaW50LnggLSA1LCBlLnBvaW50LnkgLSA1XSwKICAgICAgW2UucG9pbnQueCArIDUsIGUucG9pbnQueSArIDVdCiAgICBdOwogICAgY29uc29sZS5sb2coZSkKICAgIGNvbnNvbGUubG9nKGJib3gpCiAgICAvLyBGaW5kIGZlYXR1cmVzIGludGVyc2VjdGluZyB0aGUgYm91bmRpbmcgYm94LgogICAgCiAgICBjb25zdCBzZWxlY3RlZEZlYXR1cmVzID0gbWFwYm94LnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhiYm94LCB7CiAgICAgIGxheWVyczogWydwcm9wZXJ0eS1wYXJjZWwtcG9seWdvbnMtc3VycmV5J10KICAgIH0pCiAgICBjb25zb2xlLmxvZyhzZWxlY3RlZEZlYXR1cmVzKQogICAgY29uc29sZS5sb2coc2VsZWN0ZWRGZWF0dXJlc1swXS5wcm9wZXJ0aWVzKQogICAgCiAgICBjb25zdCBwaWRzID0gc2VsZWN0ZWRGZWF0dXJlcy5tYXAoCiAgICAgIChmZWF0dXJlKSA9PiBmZWF0dXJlLnByb3BlcnRpZXMuUElECiAgICApOwoKICAgIC8vIFNldCBhIGZpbHRlciBtYXRjaGluZyBzZWxlY3RlZCBmZWF0dXJlcyBieSBQSUQgY29kZQogICAgLy8gdG8gYWN0aXZhdGUgdGhlICdjb3VudGllcy1oaWdobGlnaHRlZCcgbGF5ZXIuCiAgICBtYXBib3guc2V0RmlsdGVyKCdwcm9wZXJ0eS1wYXJjZWwtcG9seWdvbnMtc3VycmV5LWhpZ2hsaWdodGVkJywgWydpbicsICdQSUQnLCAuLi5waWRzXSk7CgogICAgY29uc3QgYXJlYV9kaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FsY3VsYXRlZC1hcmVhJykKICAgIGNvbnN0IHBpZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwaWQnKQogICAgY29uc3QgZnJlZWZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJlZWZvcm0nKQogICAgY29uc3QgcGVyaW1ldGVyX2RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYWxjdWxhdGVkLXBlcmltZXRlcicpCiAgICBjb25zdCB6b25lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3pvbmUnKQogICAgY29uc3QgYnVpbHRfYXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidWlsdC1hcmVhJykKCiAgICBpZiAocGlkcy5sZW5ndGggPiAwKSB7CiAgICAgIGNvbnN0IGdlb20gPSBzZWxlY3RlZEZlYXR1cmVzWzBdLmdlb21ldHJ5CiAgICAgIGNvbnN0IGFyZWEgPSBNYXRoLnJvdW5kKHR1cmYuYXJlYShnZW9tKSAqIDEwMCkgLyAxMDAKICAgICAgY29uc29sZS5sb2coZ2VvbSkKICAgICAgY29uc3QgcGVyaW1ldGVyID0gTWF0aC5yb3VuZCh0dXJmLmxlbmd0aCh0dXJmLnBvbHlnb25Ub0xpbmUoZ2VvbSkpICogMTAwMCkKICAgICAgcGlkLmlubmVySFRNTCA9ICctJwogICAgICBhcmVhX2Rpdi5pbm5lckhUTUwgPSBgPHA+PHN0cm9uZz4ke2FyZWF9PC9zdHJvbmc+IG3CsjwvcD5gCiAgICAgIGZyZWVmb3JtLmlubmVySFRNTCA9ICctJwogICAgICBwZXJpbWV0ZXJfZGl2LmlubmVySFRNTCA9IGA8cD48c3Ryb25nPiR7cGVyaW1ldGVyfTwvc3Ryb25nPiBtPC9wPmAKICAgICAgem9uZS5pbm5lckhUTUwgPSAnLScKICAgICAgYnVpbHRfYXJlYS5pbm5lckhUTUwgPSAnLScKICAgIH0gZWxzZSB7CiAgICAgIGFyZWFfZGl2LmlubmVySFRNTCA9ICctJwogICAgICBwaWQuaW5uZXJIVE1MID0gJy0nCiAgICAgIGZyZWVmb3JtLmlubmVySFRNTCA9ICctJwogICAgICBwZXJpbWV0ZXJfZGl2LmlubmVySFRNTCA9ICctJwogICAgICB6b25lLmlubmVySFRNTCA9ICctJwogICAgICBidWlsdF9hcmVhLmlubmVySFRNTCA9ICctJwogICAgfQogIH0pCn0KCgpmdW5jdGlvbiBjcmVhdGVEcmF3KG1hcGJveCwgZHJhdywgd2lkdGhSYW5nZSkgewogIHdpZHRoUmFuZ2UKICBtYXBib3guYWRkU291cmNlKCdkcmF3JywgewogICAgJ3R5cGUnOiAnZ2VvanNvbicsCiAgICAnZGF0YSc6IGdlbmVyYXRlQmxvY2tzKGRyYXcsIHdpZHRoUmFuZ2UpLAogIH0pOwogIG1hcGJveC5hZGRMYXllcih7CiAgICAnaWQnOiAnb3V0bGluZScsCiAgICAndHlwZSc6ICdmaWxsJywKICAgICdzb3VyY2UnOiAnZHJhdycsCiAgICAncGFpbnQnOiB7CiAgICAgICdmaWxsLWNvbG9yJzogJyMwNmJlN2YnLAogICAgfQogIH0pOwp9CgoKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICJUaHJlZWJveEV4YW1wbGUiLAoKICBtb3VudGVkKCkgewogICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2xvYWRNYXAnKQogICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ3NldERyYXcnKQogICAgLy8gdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2dlbmVyYXRlUG9seWdvbnMnKQogICAgLy8gdGhpcy5pbml0TWFwKCkKICAgIC8vIHRoaXMuYWRkRHJhd0NvbnRyb2xzKCkKICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29ucygpCiAgfSwKICBjb21wdXRlZDogewogICAgYWNjZXNzVG9rZW4oKXsKICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLnN0YXRlLmFjY2Vzc1Rva2VuCiAgICB9LAogICAgZ2V0RHJhdygpewogICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVycy5kcmF3CiAgICB9LAogICAgd2lkdGhSYW5nZSgpewogICAgICByZXR1cm4gdGhpcy4kc3RvcmUuc3RhdGUud2lkdGhSYW5nZQogICAgfSwKICAgIGdldE1hcCgpewogICAgICByZXR1cm4gdGhpcy4kc3RvcmUuc3RhdGUubWFwYm94CiAgICB9LAogIH0sCiAgY29tcG9uZW50czogewogICAgLy8gUmFuZ2VTbGlkZXIKICB9LAogIG1ldGhvZHM6IHsKICAgIC8vIGxvYWRNYXAgKGNvbnRleHQpIHsKICAgIC8vICAgbWFwYm94Z2wuYWNjZXNzVG9rZW4gPSB0aGlzLnN0YXRlLmFjY2Vzc1Rva2VuCiAgICAvLyAgIHZhciBtYXBib3ggPSBuZXcgbWFwYm94Z2wuTWFwKHsKICAgIC8vICAgICBjb250YWluZXI6ICJtYXAiLAogICAgLy8gICAgIGludGVyYWN0aXZlOiB0cnVlLAogICAgLy8gICAgIHN0eWxlOiAgIm1hcGJveDovL3N0eWxlcy9tYXBib3gvZGFyay12MTAiLAogICAgLy8gICAgIHpvb206IDE2LAogICAgLy8gICAgIGNlbnRlcjogWy0xMjMuMTA2ODY1OCwgNDkuMjYyNjk4Ml0sCiAgICAvLyAgICAgcGl0Y2g6IDYwLAogICAgLy8gICAgIGJlYXJpbmc6IDM2MCwKICAgIC8vICAgICBhbnRpYWxpYXM6IHRydWUsCiAgICAvLyAgICAgYXR0cmlidXRpb25Db250cm9sOiBmYWxzZQogICAgLy8gICB9KQogICAgLy8gICBjb250ZXh0LmNvbW1pdCgnbG9hZE1hcCcsIG1hcGJveCkKICAgIC8vIH0sCiAgICAvLyBzZXREcmF3IChjb250ZXh0KSB7CiAgICAvLyAgIC8vIEFkZCBkcmF3IGNvbnRyb2xzCiAgICAvLyAgIGNvbnN0IGRyYXcgPSBuZXcgTWFwYm94RHJhdygpOwogICAgLy8gICB0aGlzLnN0YXRlLm1hcGJveC5hZGRDb250cm9sKGRyYXcsICd0b3AtcmlnaHQnKTsKICAgIC8vICAgY29udGV4dC5jb21taXQoJ3NldERyYXcnLCB0aGlzLmRyYXcpCiAgICAvLyB9LAogICAgc3BoZXJlKGxvbiwgbGF0KSB7CiAgICAgIGxldCBvcmlnaW4gPSBbbG9uLCBsYXQsIDBdOwogICAgICByZXR1cm4gd2luZG93LnRiCiAgICAgICAgLnNwaGVyZSh7IGNvbG9yOiAicmVkIiwgbWF0ZXJpYWw6ICJNZXNoVG9vbk1hdGVyaWFsIiB9KQogICAgICAgIC5zZXRDb29yZHMob3JpZ2luKTsKICAgIH0sCiAgICBhbmltYXRlUHVsc2UoKSB7CiAgICAgIHB1bHNlLnVwZGF0ZSgpOwogICAgICB0aGlzLm1hcGJveC50cmlnZ2VyUmVwYWludCgpOwogICAgfSwKICAgIGluaXRNYXAoKSB7CiAgICAgIG1hcGJveGdsLmFjY2Vzc1Rva2VuID0gdGhpcy5hY2Nlc3NUb2tlbjsKICAgICAgdGhpcy5tYXBib3ggPSBuZXcgbWFwYm94Z2wuTWFwKHsKICAgICAgICBjb250YWluZXI6ICJtYXAiLAogICAgICAgIGludGVyYWN0aXZlOiB0cnVlLAogICAgICAgIHN0eWxlOiAgIm1hcGJveDovL3N0eWxlcy9tYXBib3gvZGFyay12MTAiLAogICAgICAgIHpvb206IDE2LAogICAgICAgIGNlbnRlcjogWy0xMjMuMTA2ODY1OCwgNDkuMjYyNjk4Ml0sCiAgICAgICAgcGl0Y2g6IDYwLAogICAgICAgIGJlYXJpbmc6IDM2MCwKICAgICAgICBhbnRpYWxpYXM6IHRydWUsCiAgICAgICAgYXR0cmlidXRpb25Db250cm9sOiBmYWxzZQogICAgICB9KS5vbigic3R5bGUubG9hZCIsICgpID0+IHsKICAgICAgICB3aW5kb3cudGIgPSBuZXcgVGhyZWVib3goCiAgICAgICAgICB0aGlzLm1hcGJveCwKICAgICAgICAgIHRoaXMubWFwYm94LmdldENhbnZhcygpLmdldENvbnRleHQoIndlYmdsIiksIHsKICAgICAgICAgICAgZGVmYXVsdExpZ2h0czogdHJ1ZSwKICAgICAgICAgIH0KICAgICAgICApOwoKICAgICAgICAvLyBBZGQgZHJhdyBjb250cm9sCiAgICAgICAgaWYgKHRoaXMubWFwYm94LmdldExheWVyKCJjdXN0b21fbGF5ZXIiKSA9PSBudWxsKSB7CgogICAgICAgICAgdGhpcy5tYXBib3gub24oJ2xvYWQnLCAoKSA9PiB7CgogICAgICAgICAgICAvLyAvLyBBZGQgM0QgdGVycmFpbgogICAgICAgICAgICAvLyB0aGlzLm1hcGJveC5hZGRTb3VyY2UoJ21hcGJveC1kZW0nLCB7CiAgICAgICAgICAgIC8vICAgJ3R5cGUnOiAncmFzdGVyLWRlbScsCiAgICAgICAgICAgIC8vICAgJ3VybCc6ICdtYXBib3g6Ly9tYXBib3gubWFwYm94LXRlcnJhaW4tZGVtLXYxJywKICAgICAgICAgICAgLy8gICAndGlsZVNpemUnOiA1MTIsCiAgICAgICAgICAgIC8vICAgJ21heHpvb20nOiAyMAogICAgICAgICAgICAvLyB9KTsKICAgICAgICAgICAgLy8KICAgICAgICAgICAgLy8gLy8gYWRkIHRoZSBERU0gc291cmNlIGFzIGEgdGVycmFpbiBsYXllciB3aXRoIGV4YWdnZXJhdGVkIGhlaWdodAogICAgICAgICAgICAvLyB0aGlzLm1hcGJveC5zZXRUZXJyYWluKHsgJ3NvdXJjZSc6ICdtYXBib3gtZGVtJywgJ2V4YWdnZXJhdGlvbic6IDEuNSB9KTsKCiAgICAgICAgICAgIC8vIC8vIEFkZCBwYXJjZWxzIGxheWVyIHNvdXJjZSAoQ29WKQogICAgICAgICAgICAvLyB0aGlzLm1hcGJveC5hZGRTb3VyY2UoJ3Byb3BlcnR5LXBhcmNlbC1wb2x5Z29ucycsIHsKICAgICAgICAgICAgLy8gICAndHlwZSc6ICdnZW9qc29uJywKICAgICAgICAgICAgLy8gICAnZGF0YSc6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vbmljaG9sYXNtYXJ0aW5vL3Z1ZS10aHJlZWJveC9tYXN0ZXIvcHVibGljL2RhdGEvcHJvcGVydHktcGFyY2VsLXBvbHlnb25zLmdlb2pzb24nLAogICAgICAgICAgICAvLyB9KTsKICAgICAgICAgICAgLy8KICAgICAgICAgICAgLy8gLy8gQWRkIHBhcmNlbHMgbGF5ZXIgdG8gbWFwCiAgICAgICAgICAgIC8vIHRoaXMubWFwYm94LmFkZExheWVyKHsKICAgICAgICAgICAgLy8gICAnaWQnOiAncHJvcGVydHktcGFyY2VsLXBvbHlnb25zLXNocCcsCiAgICAgICAgICAgIC8vICAgJ3R5cGUnOiAnZmlsbCcsCiAgICAgICAgICAgIC8vICAgJ3NvdXJjZSc6ICdwcm9wZXJ0eS1wYXJjZWwtcG9seWdvbnMnLAogICAgICAgICAgICAvLyAgICdwYWludCc6IHsKICAgICAgICAgICAgLy8gICAgICdmaWxsLWNvbG9yJzogJyMwMDgwZmYnLCAvLyBibHVlIGNvbG9yIGZpbGwKICAgICAgICAgICAgLy8gICAgICdmaWxsLW9wYWNpdHknOiAwLjIsCiAgICAgICAgICAgIC8vICAgfSwKICAgICAgICAgICAgLy8gfSk7CgogICAgICAgICAgICAvLyBUaGUgJ2J1aWxkaW5nJyBsYXllciBpbiB0aGUgTWFwYm94IFN0cmVldHMKICAgICAgICAgICAgLy8gdmVjdG9yIHRpbGVzZXQgY29udGFpbnMgYnVpbGRpbmcgaGVpZ2h0IGRhdGEKICAgICAgICAgICAgLy8gZnJvbSBPcGVuU3RyZWV0TWFwLgogICAgICAgICAgICB0aGlzLm1hcGJveC5hZGRMYXllcih7CiAgICAgICAgICAgICAgJ2lkJzogJ2FkZC0zZC1idWlsZGluZ3MnLAogICAgICAgICAgICAgICdzb3VyY2UnOiAnY29tcG9zaXRlJywKICAgICAgICAgICAgICAnc291cmNlLWxheWVyJzogJ2J1aWxkaW5nJywKICAgICAgICAgICAgICAnZmlsdGVyJzogWyc9PScsICdleHRydWRlJywgJ3RydWUnXSwKICAgICAgICAgICAgICAndHlwZSc6ICdmaWxsLWV4dHJ1c2lvbicsCiAgICAgICAgICAgICAgJ21pbnpvb20nOiAxMiwKICAgICAgICAgICAgICAncGFpbnQnOiB7CiAgICAgICAgICAgICAgICAnZmlsbC1leHRydXNpb24tY29sb3InOiAnI2FhYScsCgogICAgICAgICAgICAgICAgLy8gVXNlIGFuICdpbnRlcnBvbGF0ZScgZXhwcmVzc2lvbiB0bwogICAgICAgICAgICAgICAgLy8gYWRkIGEgc21vb3RoIHRyYW5zaXRpb24gZWZmZWN0IHRvCiAgICAgICAgICAgICAgICAvLyB0aGUgYnVpbGRpbmdzIGFzIHRoZSB1c2VyIHpvb21zIGluLgogICAgICAgICAgICAgICAgJ2ZpbGwtZXh0cnVzaW9uLWhlaWdodCc6IFsKICAgICAgICAgICAgICAgICAgJ2ludGVycG9sYXRlJywKICAgICAgICAgICAgICAgICAgWydsaW5lYXInXSwKICAgICAgICAgICAgICAgICAgWyd6b29tJ10sCiAgICAgICAgICAgICAgICAgIDksCiAgICAgICAgICAgICAgICAgIDAsCiAgICAgICAgICAgICAgICAgIDE1LjA1LAogICAgICAgICAgICAgICAgICBbJ2dldCcsICdoZWlnaHQnXQogICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICdmaWxsLWV4dHJ1c2lvbi1iYXNlJzogWwogICAgICAgICAgICAgICAgICAnaW50ZXJwb2xhdGUnLAogICAgICAgICAgICAgICAgICBbJ2xpbmVhciddLAogICAgICAgICAgICAgICAgICBbJ3pvb20nXSwKICAgICAgICAgICAgICAgICAgOSwKICAgICAgICAgICAgICAgICAgMCwKICAgICAgICAgICAgICAgICAgMTUuMDUsCiAgICAgICAgICAgICAgICAgIFsnZ2V0JywgJ21pbl9oZWlnaHQnXQogICAgICAgICAgICAgICAgXSwKCiAgICAgICAgICAgICAgICAvLyAnZmlsbC1leHRydXNpb24taGVpZ2h0JzogWydnZXQnLCAnaGVpZ2h0J10sCiAgICAgICAgICAgICAgICAnZmlsbC1leHRydXNpb24tb3BhY2l0eSc6IDAuOCwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9KTsKICAgICAgICAgIH0pOwoKICAgICAgICAgIC8vIC8vIEFkZCBzcGhlcmVzIHRvIG1hcAogICAgICAgICAgLy8gY29uc3QgX3RoaXMgPSB0aGlzCiAgICAgICAgICAvLyB0aGlzLm1hcGJveC5hZGRMYXllcih7CiAgICAgICAgICAvLyAgIGlkOiAiY3VzdG9tX2xheWVyIiwKICAgICAgICAgIC8vICAgdHlwZTogImN1c3RvbSIsCiAgICAgICAgICAvLyAgIHJlbmRlcmluZ01vZGU6ICIzZCIsCiAgICAgICAgICAvLwogICAgICAgICAgLy8gICBvbkFkZDogZnVuY3Rpb24gKG1hcCwgbWJ4Q29udGV4dCkgewogICAgICAgICAgLy8gICAgIHdpbmRvdy50Yi5hZGQoX3RoaXMuc3BoZXJlKC0xMjMuMTA2ODY1OCwgNDkuMjYyNjk4MikpOwogICAgICAgICAgLy8gICAgIHdpbmRvdy50Yi5hZGQoX3RoaXMuc3BoZXJlKC0xMjMuMTA4ODY1OCwgNDkuMjYyNjk4MikpOwogICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKG1hcCkKICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhtYnhDb250ZXh0KQogICAgICAgICAgLy8gICAgIGxldCBwdWxzZU9iaiA9IHdpbmRvdy50YgogICAgICAgICAgLy8gICAgICAgLk9iamVjdDNEKHsgb2JqOiBwdWxzZSwgdW5pdHM6ICJtZXRlcnMiIH0pCiAgICAgICAgICAvLyAgICAgICAuc2V0Q29vcmRzKFstMTIzLjEwNjg2NTgsIDQ5LjI2MjY5ODIsIDBdKTsKICAgICAgICAgIC8vCiAgICAgICAgICAvLyAgICAgcHVsc2VPYmouc2V0QW5jaG9yKCJib3R0b20tbGVmdCIpOwogICAgICAgICAgLy8KICAgICAgICAgIC8vICAgICB3aW5kb3cudGIuYWRkKHB1bHNlT2JqKTsKICAgICAgICAgIC8vICAgfSwKICAgICAgICAgIC8vICAgcmVuZGVyOiBmdW5jdGlvbiAoZ2wsIG1hdHJpeCkgewogICAgICAgICAgLy8gICAgIHdpbmRvdy50Yi51cGRhdGUoKTsKICAgICAgICAgIC8vICAgICBfdGhpcy5hbmltYXRlUHVsc2UoKTsKICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhnbCkKICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhtYXRyaXgpCiAgICAgICAgICAvLyAgIH0sCiAgICAgICAgICAvLyB9KTsKCiAgICAgICAgfQogICAgICB9KTsKICAgICAgdGhpcy5nZW5lcmF0ZVBvbHlnb25zKCkKICAgIH0sCgogICAgYWRkRHJhd0NvbnRyb2xzKCkgewogICAgICAvLyBBZGQgZHJhdyBjb250cm9scwogICAgICB0aGlzLm1hcGJveCA9IHRoaXMuJHN0b3JlLnN0YXRlLm1hcGJveAogICAgICBjb25zdCBkcmF3ID0gbmV3IE1hcGJveERyYXcoewogICAgICAgICAgY29udHJvbHM6IHsKICAgICAgICAgICAgcG9seWdvbjogdHJ1ZSwKICAgICAgICAgICAgdHJhc2g6IHRydWUKICAgICAgICB9LAogICAgICAgIGRlZmF1bHRNb2RlOiAnZHJhd19wb2x5Z29uJwogICAgICB9KTsKICAgICAgdGhpcy5tYXBib3guYWRkQ29udHJvbChkcmF3LCAndG9wLXJpZ2h0Jyk7CiAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgnc2V0RHJhdycsIHRoaXMuZHJhdykKICAgICAgdGhpcy5kcmF3ID0gZHJhdwogICAgfSwKICAgIGdlbmVyYXRlUG9seWdvbnMoKSB7CiAgICAgIHRoaXMubWFwYm94ID0gdGhpcy4kc3RvcmUuc3RhdGUubWFwYm94CiAgICAgIHRoaXMuZHJhdyA9IHRoaXMuJHN0b3JlLnN0YXRlLmRyYXcKICAgICAgY29uc29sZS5sb2coIkRyYXciLCB0aGlzLmRyYXcpCiAgICAgIHRoaXMubWFwYm94Lm9uKCdkcmF3LmNyZWF0ZScsICgpID0+IHsKICAgICAgICB1cGRhdGVBcmVhKHRoaXMuZHJhdykKICAgICAgfSkKICAgICAgdGhpcy5tYXBib3gub24oJ2RyYXcuZGVsZXRlJywgKCkgPT4gewogICAgICAgIHVwZGF0ZUFyZWEodGhpcy5kcmF3KQogICAgICB9KQogICAgICB0aGlzLm1hcGJveC5vbignZHJhdy51cGRhdGUnLCAoKSA9PiB7CiAgICAgICAgdXBkYXRlQXJlYSh0aGlzLmRyYXcpCiAgICAgIH0pCgogICAgICB0aGlzLm1hcGJveC5vbignZHJhdy5jcmVhdGUnLCAoKSA9PiB7CiAgICAgICAgY3JlYXRlRHJhdyh0aGlzLm1hcGJveCwgdGhpcy5kcmF3LCB0aGlzLndpZHRoUmFuZ2UpCiAgICAgIH0pOwoKICAgICAgdGhpcy5tYXBib3gub24oJ2NsaWNrJywgKCkgPT4gewogICAgICAgIGdldERhdGEodGhpcy5tYXBib3gpCiAgICAgIH0pCgogICAgICB0aGlzLm1hcGJveC5vbignZHJhdy5kZWxldGUnLCAoKSA9PiB7CiAgICAgICAgZGVsZXRlT3V0bGluZURyYXdzKHRoaXMubWFwYm94KQogICAgICB9KTsKCiAgICAgIHRoaXMubWFwYm94Lm9uKCdkcmF3LnVwZGF0ZScsICgpID0+IHsKICAgICAgICB1cGRhdGVEcmF3KHRoaXMubWFwYm94LCB0aGlzLmRyYXcsIHRoaXMud2lkdGhSYW5nZSkKICAgICAgfSk7CiAgICB9CiAgfSwKfTsKCgoK"},{"version":3,"sources":["Map.vue"],"names":[],"mappings":";;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"Map.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div>\n    <div id=\"map\" v-on:draw=\"generatePolygons()\"></div>\n    <!-- <div id=\"vue-range-slider\">\n      <RangeSlider v-on:changeValue=\"generatePolygons()\"/>\n    </div> -->\n  </div>\n</template>\n\n<script>\nimport mapboxgl from \"mapbox-gl\";\nimport * as MapboxDraw from 'mapbox-gl-draw';\nimport threebox from \"threebox-plugin/dist/threebox\";\nimport { Threebox } from 'threebox-plugin';\nimport Pulse from \"./Pulses/Pulse\";\nimport * as turf from '@turf/turf';\n// import RangeSlider from \"./RangeSlider\"\n\n\nlet pulse = new Pulse(400, 4000, true);\nthreebox\n\n\n// Calculate the area of drawn polygons\nfunction updateArea(draw) {\n    const data = draw.getAll();\n    const area_div = document.getElementById('calculated-area')\n\n    if (data.features.length > 0) {\n      const area = Math.round(turf.area(data) * 100) / 100\n      // Restrict the area to 2 decimal points.\n      area_div.innerHTML = `<p><strong>${area}</strong> m²</p>`\n    } else {\n      area_div.innerHTML = `-`\n\n      // if (e.type !== 'draw.delete')\n      //   alert('Click the map to draw a polygon.');\n  }\n}\n\n// Returns true if finds a defined key in the input array of dictionaries\nfunction keyInDictionary (dictionaries, keyToFind) {\n    for (var i in dictionaries) {\n        if (dictionaries[i]['id'] == keyToFind) {\n            return true\n        }\n    }\n}\n\n\n// Returns a list of centroids of multiple LineStrings\nfunction lineCentroids(lines) {\n  const centroids = [];\n  for (let i = 0; i < lines.features.length; i++) {\n    const line = turf.lineString(lines.features[i])\n    const ctr = turf.centroid(line['geometry']['coordinates'])\n    centroids.push(ctr)\n  }\n  return centroids\n}\n\n\n// Returns points along a LineString divided according to a specified length in meters\nfunction divideLineString(line, length=100) {\n  const chunks = turf.lineChunk(line, length, {units: 'meters'})\n  return lineCentroids(chunks)\n}\n\n\n// Extract drawn shape and convert it to a polygon\nfunction getPolygonDrawn(draw){\n  const data = draw.getAll()\n  return turf.polygon(data.features[0]['geometry']['coordinates'])\n}\n\n\n// Extract internal skeleton of a shape\nfunction voronoiSkeleton(draw){\n  const pol = getPolygonDrawn(draw)\n  const line = turf.polygonToLine(pol)\n  const chunks = turf.lineChunk(line, 0.01)\n  const centroids = lineCentroids(chunks)\n  const centroids_gj = {\n    \"type\": \"FeatureCollection\",\n    \"features\": centroids\n  }\n  const voronoi = turf.voronoi(centroids_gj)\n  // Iterate over voronoi polygons to extract segments inside drawing\n  const voronoiLines = [];\n  for (let i = 0; i < voronoi.features.length; i++) {\n    const voronoiPolygon = turf.polygon(voronoi.features[i]['geometry']['coordinates']);\n    const voronoiLine = turf.polygonToLine(voronoiPolygon)\n    const voronoiSegments = turf.lineSegment(voronoiLine)\n    for (let i = 0; i < voronoiSegments.features.length; i++) {\n      const segmentCentroid = turf.centroid(voronoiSegments.features[i])\n      if (turf.booleanContains(pol, segmentCentroid)) {\n        voronoiLines.push(voronoiSegments.features[i])\n      }\n    }\n  }\n  const voronoiLinesGeoJSON = {\n    \"type\": \"FeatureCollection\",\n    \"features\": voronoiLines\n  }\n  const voronoiLinesCombined = turf.combine(voronoiLinesGeoJSON)\n  const voronoiLinesSimplified = turf.simplify(voronoiLinesCombined,\n    {tolerance: 5, mutate: true})\n  return voronoiLinesSimplified\n}\n\n\n// Generate skeleton and buffer according to some number of iterations\nfunction bufferDrawSkeleton(skeleton) {\n  const bufferedSkeletons = []\n  for (let i = 0; i < 3; i++) {\n    const skeletonBuffer = turf.buffer(skeleton, 30 * (i+1), {units: 'meters'})\n    const dissolvedSkeleton = turf.dissolve(skeletonBuffer)\n    bufferedSkeletons.push(turf.lineString(dissolvedSkeleton.features[0]['geometry']['coordinates'][0]))\n  }\n  return bufferedSkeletons\n}\n\n\n// Subdivide a drawn shape using Voronoi patterns\nfunction subdivideShape(draw) {\n  const output = {}\n  const skeleton = voronoiSkeleton(draw)\n  output.skeleton = skeleton.features\n  const skeletonBufferSmall = turf.buffer(skeleton, 0.1, {units: 'meters'}).features[0]\n  const skeletonLine = turf.polygonToLine(skeletonBufferSmall)\n  const dividedSkeleton = divideLineString(turf.combine(skeletonLine))\n  const voronoiSkeletonBuffers = bufferDrawSkeleton(skeleton)\n  output.voronoiSkeletonBuffers = voronoiSkeletonBuffers\n  output.perpendicularLines = []\n  for (let i = 0; i < dividedSkeleton.length; i++) {\n    var originalPoint = dividedSkeleton[i]\n    const nearestPoints = [originalPoint['geometry']['coordinates']]\n    for (let j = 0; j < voronoiSkeletonBuffers.length; j++) {\n      const buffer = voronoiSkeletonBuffers[j]\n      const nextPoint = turf.nearestPointOnLine(buffer, turf.point(originalPoint['geometry']['coordinates']))\n      nearestPoints.push(nextPoint['geometry']['coordinates'])\n      originalPoint = nextPoint\n    }\n    output.perpendicularLines.push(turf.lineString(nearestPoints))\n  }\n  return output\n}\n\n// Buffer generated lines according to buffer range and subtract from original drawing\nfunction generateBlocks(draw, bufferRange) {\n  const bufferOptions = {units: 'meters'}\n  const subdivisions = subdivideShape(draw)\n  const skeletonBuffer = turf.buffer(subdivisions.skeleton[0], bufferRange[1]/2, bufferOptions)\n  const perpendicularsBuffered = turf.buffer(turf.featureCollection(subdivisions.perpendicularLines), (bufferRange[0] + bufferRange[1])/4, bufferOptions)\n  const parallelsBuffered = turf.buffer(turf.featureCollection(subdivisions.voronoiSkeletonBuffers), bufferRange[0]/2, bufferOptions)\n  const allBuffers = perpendicularsBuffered.features.concat(parallelsBuffered.features, skeletonBuffer)\n  \n  // Iterate over buffers to extract coords\n  const allBuffersCoords = []\n  for (let i = 0; i < allBuffers.length; i++) {\n    console.log(allBuffers[i])\n    const buffer = allBuffers[i].geometry.coordinates\n    allBuffersCoords.push(buffer)\n  }\n  // const bufferedCenterlines = turf.dissolve(allBuffers)\n  // console.log(\"Centelrines dissolved\")\n  console.log(turf.multiPolygon(allBuffersCoords))\n  const difference = turf.difference(getPolygonDrawn(draw), turf.multiPolygon(allBuffersCoords))\n  console.log(\"Subtraction performed\")\n  const simplified = turf.simplify(difference, {tolerance: 0.00001})\n  console.log(\"Simplification completed\")\n  return simplified\n}\n\n\nfunction deleteOutlineDraws(map) {\n  if (keyInDictionary(map.getStyle().layers, 'outline')) {\n    map.removeLayer('outline')\n  }\n  if ('draw' in map.getStyle().sources) {\n    map.removeSource('draw')\n  }\n}\n\n\nexport function updateDraw(mapbox, draw, widthRange) {\n  deleteOutlineDraws(mapbox)\n  mapbox.addSource('draw', {\n    'type': 'geojson',\n    'data': generateBlocks(draw, widthRange),\n  });\n  mapbox.addLayer({\n    'id': 'outline',\n    'type': 'fill',\n    'source': 'draw',\n    'paint': {\n      'fill-color': '#06be7f' // red color\n    }\n  });\n}\n\n\nfunction getData(mapbox) {\n    mapbox.on('click', (e) => {\n    // Set `bbox` as 5px reactangle area around clicked point.\n    const bbox = [\n      [e.point.x - 5, e.point.y - 5],\n      [e.point.x + 5, e.point.y + 5]\n    ];\n    console.log(e)\n    console.log(bbox)\n    // Find features intersecting the bounding box.\n    \n    const selectedFeatures = mapbox.queryRenderedFeatures(bbox, {\n      layers: ['property-parcel-polygons-surrey']\n    })\n    console.log(selectedFeatures)\n    console.log(selectedFeatures[0].properties)\n    \n    const pids = selectedFeatures.map(\n      (feature) => feature.properties.PID\n    );\n\n    // Set a filter matching selected features by PID code\n    // to activate the 'counties-highlighted' layer.\n    mapbox.setFilter('property-parcel-polygons-surrey-highlighted', ['in', 'PID', ...pids]);\n\n    const area_div = document.getElementById('calculated-area')\n    const pid = document.getElementById('pid')\n    const freeform = document.getElementById('freeform')\n    const perimeter_div = document.getElementById('calculated-perimeter')\n    const zone = document.getElementById('zone')\n    const built_area = document.getElementById('built-area')\n\n    if (pids.length > 0) {\n      const geom = selectedFeatures[0].geometry\n      const area = Math.round(turf.area(geom) * 100) / 100\n      console.log(geom)\n      const perimeter = Math.round(turf.length(turf.polygonToLine(geom)) * 1000)\n      pid.innerHTML = '-'\n      area_div.innerHTML = `<p><strong>${area}</strong> m²</p>`\n      freeform.innerHTML = '-'\n      perimeter_div.innerHTML = `<p><strong>${perimeter}</strong> m</p>`\n      zone.innerHTML = '-'\n      built_area.innerHTML = '-'\n    } else {\n      area_div.innerHTML = '-'\n      pid.innerHTML = '-'\n      freeform.innerHTML = '-'\n      perimeter_div.innerHTML = '-'\n      zone.innerHTML = '-'\n      built_area.innerHTML = '-'\n    }\n  })\n}\n\n\nfunction createDraw(mapbox, draw, widthRange) {\n  widthRange\n  mapbox.addSource('draw', {\n    'type': 'geojson',\n    'data': generateBlocks(draw, widthRange),\n  });\n  mapbox.addLayer({\n    'id': 'outline',\n    'type': 'fill',\n    'source': 'draw',\n    'paint': {\n      'fill-color': '#06be7f',\n    }\n  });\n}\n\n\nexport default {\n  name: \"ThreeboxExample\",\n\n  mounted() {\n    this.$store.dispatch('loadMap')\n    this.$store.dispatch('setDraw')\n    // this.$store.dispatch('generatePolygons')\n    // this.initMap()\n    // this.addDrawControls()\n    this.generatePolygons()\n  },\n  computed: {\n    accessToken(){\n      return this.$store.state.accessToken\n    },\n    getDraw(){\n      return this.$store.getters.draw\n    },\n    widthRange(){\n      return this.$store.state.widthRange\n    },\n    getMap(){\n      return this.$store.state.mapbox\n    },\n  },\n  components: {\n    // RangeSlider\n  },\n  methods: {\n    // loadMap (context) {\n    //   mapboxgl.accessToken = this.state.accessToken\n    //   var mapbox = new mapboxgl.Map({\n    //     container: \"map\",\n    //     interactive: true,\n    //     style:  \"mapbox://styles/mapbox/dark-v10\",\n    //     zoom: 16,\n    //     center: [-123.1068658, 49.2626982],\n    //     pitch: 60,\n    //     bearing: 360,\n    //     antialias: true,\n    //     attributionControl: false\n    //   })\n    //   context.commit('loadMap', mapbox)\n    // },\n    // setDraw (context) {\n    //   // Add draw controls\n    //   const draw = new MapboxDraw();\n    //   this.state.mapbox.addControl(draw, 'top-right');\n    //   context.commit('setDraw', this.draw)\n    // },\n    sphere(lon, lat) {\n      let origin = [lon, lat, 0];\n      return window.tb\n        .sphere({ color: \"red\", material: \"MeshToonMaterial\" })\n        .setCoords(origin);\n    },\n    animatePulse() {\n      pulse.update();\n      this.mapbox.triggerRepaint();\n    },\n    initMap() {\n      mapboxgl.accessToken = this.accessToken;\n      this.mapbox = new mapboxgl.Map({\n        container: \"map\",\n        interactive: true,\n        style:  \"mapbox://styles/mapbox/dark-v10\",\n        zoom: 16,\n        center: [-123.1068658, 49.2626982],\n        pitch: 60,\n        bearing: 360,\n        antialias: true,\n        attributionControl: false\n      }).on(\"style.load\", () => {\n        window.tb = new Threebox(\n          this.mapbox,\n          this.mapbox.getCanvas().getContext(\"webgl\"), {\n            defaultLights: true,\n          }\n        );\n\n        // Add draw control\n        if (this.mapbox.getLayer(\"custom_layer\") == null) {\n\n          this.mapbox.on('load', () => {\n\n            // // Add 3D terrain\n            // this.mapbox.addSource('mapbox-dem', {\n            //   'type': 'raster-dem',\n            //   'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',\n            //   'tileSize': 512,\n            //   'maxzoom': 20\n            // });\n            //\n            // // add the DEM source as a terrain layer with exaggerated height\n            // this.mapbox.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });\n\n            // // Add parcels layer source (CoV)\n            // this.mapbox.addSource('property-parcel-polygons', {\n            //   'type': 'geojson',\n            //   'data': 'https://raw.githubusercontent.com/nicholasmartino/vue-threebox/master/public/data/property-parcel-polygons.geojson',\n            // });\n            //\n            // // Add parcels layer to map\n            // this.mapbox.addLayer({\n            //   'id': 'property-parcel-polygons-shp',\n            //   'type': 'fill',\n            //   'source': 'property-parcel-polygons',\n            //   'paint': {\n            //     'fill-color': '#0080ff', // blue color fill\n            //     'fill-opacity': 0.2,\n            //   },\n            // });\n\n            // The 'building' layer in the Mapbox Streets\n            // vector tileset contains building height data\n            // from OpenStreetMap.\n            this.mapbox.addLayer({\n              'id': 'add-3d-buildings',\n              'source': 'composite',\n              'source-layer': 'building',\n              'filter': ['==', 'extrude', 'true'],\n              'type': 'fill-extrusion',\n              'minzoom': 12,\n              'paint': {\n                'fill-extrusion-color': '#aaa',\n\n                // Use an 'interpolate' expression to\n                // add a smooth transition effect to\n                // the buildings as the user zooms in.\n                'fill-extrusion-height': [\n                  'interpolate',\n                  ['linear'],\n                  ['zoom'],\n                  9,\n                  0,\n                  15.05,\n                  ['get', 'height']\n                ],\n                'fill-extrusion-base': [\n                  'interpolate',\n                  ['linear'],\n                  ['zoom'],\n                  9,\n                  0,\n                  15.05,\n                  ['get', 'min_height']\n                ],\n\n                // 'fill-extrusion-height': ['get', 'height'],\n                'fill-extrusion-opacity': 0.8,\n              },\n            });\n          });\n\n          // // Add spheres to map\n          // const _this = this\n          // this.mapbox.addLayer({\n          //   id: \"custom_layer\",\n          //   type: \"custom\",\n          //   renderingMode: \"3d\",\n          //\n          //   onAdd: function (map, mbxContext) {\n          //     window.tb.add(_this.sphere(-123.1068658, 49.2626982));\n          //     window.tb.add(_this.sphere(-123.1088658, 49.2626982));\n          //     console.log(map)\n          //     console.log(mbxContext)\n          //     let pulseObj = window.tb\n          //       .Object3D({ obj: pulse, units: \"meters\" })\n          //       .setCoords([-123.1068658, 49.2626982, 0]);\n          //\n          //     pulseObj.setAnchor(\"bottom-left\");\n          //\n          //     window.tb.add(pulseObj);\n          //   },\n          //   render: function (gl, matrix) {\n          //     window.tb.update();\n          //     _this.animatePulse();\n          //     console.log(gl)\n          //     console.log(matrix)\n          //   },\n          // });\n\n        }\n      });\n      this.generatePolygons()\n    },\n\n    addDrawControls() {\n      // Add draw controls\n      this.mapbox = this.$store.state.mapbox\n      const draw = new MapboxDraw({\n          controls: {\n            polygon: true,\n            trash: true\n        },\n        defaultMode: 'draw_polygon'\n      });\n      this.mapbox.addControl(draw, 'top-right');\n      this.$store.commit('setDraw', this.draw)\n      this.draw = draw\n    },\n    generatePolygons() {\n      this.mapbox = this.$store.state.mapbox\n      this.draw = this.$store.state.draw\n      console.log(\"Draw\", this.draw)\n      this.mapbox.on('draw.create', () => {\n        updateArea(this.draw)\n      })\n      this.mapbox.on('draw.delete', () => {\n        updateArea(this.draw)\n      })\n      this.mapbox.on('draw.update', () => {\n        updateArea(this.draw)\n      })\n\n      this.mapbox.on('draw.create', () => {\n        createDraw(this.mapbox, this.draw, this.widthRange)\n      });\n\n      this.mapbox.on('click', () => {\n        getData(this.mapbox)\n      })\n\n      this.mapbox.on('draw.delete', () => {\n        deleteOutlineDraws(this.mapbox)\n      });\n\n      this.mapbox.on('draw.update', () => {\n        updateDraw(this.mapbox, this.draw, this.widthRange)\n      });\n    }\n  },\n};\n\n\n\n</script>\n\n\n<style>\n#map {\n  position: absolute;\n  margin-left: 30vw;\n  width: 70vw;\n  height: 100vh;\n}\n@import \"https://api.mapbox.com/mapbox-gl-js/v0.42.0/mapbox-gl.css\";\n@import \"https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.2/mapbox-gl-draw.css\";\n@import \"https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.0/mapbox-gl.css\";\n.mapboxgl-ctrl-group button {\n    width: 29px;\n    height: 29px;\n    display: block;\n    padding: 0;\n    outline: none;\n    border: 0;\n    box-sizing: border-box;\n    background-color: transparent;\n    cursor: pointer;\n    overflow: hidden;\n}\n.mapboxgl-ctrl-top-right {\n    top: 0;\n    right: 0;\n    position: absolute;\n}\n.marker:before {\n  content: \"\";\n  cursor: pointer;\n  position: absolute;\n  width: 25px;\n  height: 25px;\n  border: 1px solid #ccc;\n  border-radius: 75% 45% 75% 0%;\n  background: #3498db;\n  bottom: 0;\n  transform-origin: 0% 100%;\n  transform: rotate(-45deg) scale(1);\n}\n</style>\n"]}]}